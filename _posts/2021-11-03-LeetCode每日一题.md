---
redirect_from: /_posts/2021-11-03-LeetCode每日一题.md/
title: LeetCode每日一题
tags:
  - Java
  - DataStructure
---

# 每日一题

## [Easy] 453. Minimum Moves to Equal Array Elements

Given an integer array `nums` of size `n`, return *the minimum number of moves required to make all array elements equal*.

In one move, you can increment `n - 1` elements of the array by `1`.

 

**Example 1:**

```
Input: nums = [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements):
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```

**Example 2:**

```
Input: nums = [1,1,1]
Output: 0
```

 

**Constraints:**

- `n == nums.length`
- `1 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- The answer is guaranteed to fit in a **32-bit** integer.

### My solution

n-1个元素增加一，相当于剩下的一个元素减小1。只需找到最小的元素，移动次数即为最小元素与各个元素的差的和；

```java
class Solution {
    public int minMoves(int[] nums) {
        // Arrays.sort(nums);
        // int minnum = nums[0];
        int minnum = Arrays.stream(nums).min().getAsInt();
        int res=0;
        for(int i=0;i<nums.length;i++){
            res+=nums[i]-minnum;
        }
        return res;
    }
}
```

优化后：

```java
class Solution {
    public int minMoves(int[] nums) {
        int minnum = nums[0];
        int sum=minnum;
        for(int i=1;i<nums.length;i++){
            if(nums[i]<minnum){
                minnum = nums[i];
            }
            sum+=nums[i];
        }
        return sum-minnum*nums.length;
    }
}
```





## [Medium] 151. Reverse Words in a String

Given an input string `s`, reverse the order of the **words**.

A **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.

Return *a string of the words in reverse order concatenated by a single space.*

**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

 

**Example 1:**

```
Input: s = "the sky is blue"
Output: "blue is sky the"
```

**Example 2:**

```
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
```

**Example 3:**

```
Input: s = "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
```

**Example 4:**

```
Input: s = "  Bob    Loves  Alice   "
Output: "Alice Loves Bob"
```

**Example 5:**

```
Input: s = "Alice does not even like bob"
Output: "bob like even not does Alice"
```

 

**Constraints:**

- `1 <= s.length <= 104`
- `s` contains English letters (upper-case and lower-case), digits, and spaces `' '`.
- There is **at least one** word in `s`.

 

**Follow-up:** If the string data type is mutable in your language, can you solve it **in-place** with `O(1)` extra space?



### Solution

使用库函数

```java
class Solution {
    public String reverseWords(String s) {
        String[] res = s.trim().split(" +");
        Collections.reverse(Arrays.asList(res));
        return String.join(" ", res);
    }
}
```

O(1) extra space 解法

- 去除多余的空格

- 把每一个单词逆置
- 再把整个字符串翻转

```java
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = removeSpace(s);
        reverseEverything(sb,0,sb.length()-1);
        reverseEachWord(sb);
        return sb.toString();
    }
    
    private StringBuilder removeSpace(String s) {
        int start = 0, end = s.length()-1;
        while(s.charAt(start)==' ') {
            start++;
        }
        while(s.charAt(end)==' ') {
            end--;
        }
        StringBuilder sb = new StringBuilder();
        while(start<=end) {
            char c = s.charAt(start);
            if(c != ' '||sb.charAt(sb.length()-1) != ' ') {
                sb.append(c);
            }
            start++;
        }
        return sb;
    }
    
    private void reverseEverything(StringBuilder sb, int start, int end) {
        while(start<end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
        }
        
    }
    
    private void reverseEachWord(StringBuilder sb) {
        int start = 0, end = 1;
        while(start < sb.length()) {
            while((end<sb.length())&&(sb.charAt(end)!=' ')) {
                end++;
            }
            reverseEverything(sb,start,end-1);
            start = end+1;
            end = start+1;
        }
    }
}
```



## [Easy] 66. Plus One

You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.

Increment the large integer by one and return *the resulting array of digits*.

 

**Example 1:**

```
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].
```

**Example 2:**

```
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].
```

**Example 3:**

```
Input: digits = [0]
Output: [1]
Explanation: The array represents the integer 0.
Incrementing by one gives 0 + 1 = 1.
Thus, the result should be [1].
```

**Example 4:**

```
Input: digits = [9]
Output: [1,0]
Explanation: The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].
```

 

**Constraints:**

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`
- `digits` does not contain any leading `0`'s.

### My Solution

直接模拟

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int temp=1;
        for(int i = digits.length-1;i>=0;i--) {
            digits[i]+=temp;
            if(digits[i]>=10) {
                temp=digits[i]/10;
                digits[i]-=10*temp;
            } else{
                temp = 0;
            }
        }
        if(digits[0]==0&&temp>=1) {
            int[] res  = new int[digits.length+1];
            res[0]=1;
           return res;
            
        }
        return digits;
    }
}
```

找最长后缀9，第一个不为9的数+1，将末尾9置零：

```java
class Solution {
    public int[] plusOne(int[] digits) {
        for(int i = digits.length-1;i>=0;i--) {
            if(digits[i]!=9) {
                ++digits[i];
                for(int j=i+1;j<digits.length;j++) {
                    digits[j]=0;
                }
                return digits;
            } 
        }
        int[] res = new int [digits.length+1];
        res[0]=1;
        return res;        
    }
}
```



## [Medium] 380. Insert Delete GetRandom O(1)

Implement the `RandomizedSet` class:

- `RandomizedSet()` Initializes the `RandomizedSet` object.
- `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.
- `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.
- `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.

You must implement the functions of the class such that each function works in **average** `O(1)` time complexity.

 

**Example 1:**

```
Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
```

 

**Constraints:**

- `-2^31 <= val <= 2^31 - 1`
- At most `2 * 10^5` calls will be made to `insert`, `remove`, and `getRandom`.
- There will be **at least one** element in the data structure when `getRandom` is called.



### Solution

重点:  插入时记录每个元素的位置，remove时用最后的element去替换要删除的元素，删除dict中的键值对，删除list的最后一个元素。

```java
class RandomizedSet {
    
    Map<Integer, Integer> dict= new HashMap();
    List<Integer> list = new ArrayList();
    Random rand = new Random();

    public RandomizedSet() {
    }
    
    public boolean insert(int val) {
        if(dict.containsKey(val)){
            return false;
        }
        dict.put(val,list.size());
        list.add(list.size(),val);
        return true;
    }
    
    public boolean remove(int val) {
        if(!dict.containsKey(val)){
            return false;
        }
        int lastElement = list.get(list.size()-1);
        int id = dict.get(val);
        list.set(id,lastElement);
        dict.put(lastElement,id);
        list.remove(list.size()-1);
        dict.remove(val);
        return true;
    }
    
    public int getRandom() {
        return list.get(rand.nextInt(list.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```



## [Medium] 229. Majority Element II

Given an integer array of size `n`, find all elements that appear more than `⌊ n/3 ⌋` times.

 

**Example 1:**

```
Input: nums = [3,2,3]
Output: [3]
```

**Example 2:**

```
Input: nums = [1]
Output: [1]
```

**Example 3:**

```
Input: nums = [1,2]
Output: [1,2]
```

 

**Constraints:**

- `1 <= nums.length <= 5 * 104`
- `-109 <= nums[i] <= 109`

 

**Follow up:** Could you solve the problem in linear time and in `O(1)` space?



### Solution

 Boyer-Moore Voting Algorithm

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> ans;
        int vote1=0,vote2=0,element1=0,element2=0;
        for(int num:nums) {
            if(vote1>0&&num==element1){
                vote1++;
            } else if(vote2>0&&num==element2) {
                vote2++;
            } else if(vote1==0){
                vote1++;
                element1 = num;
            } else if (vote2==0) {
                vote2++;
                element2 = num;
            } else {
                vote2--;
                vote1--;
            }
        }

        int count1 = 0, count2 = 0;
        for(int num:nums) {
            if(vote1>0&&num==element1) {
                count1++;
            }
            if(vote2>0&&num==element2) {
                count2++;
            }
        }

        ans = new ArrayList<>();
        if(vote1>0&&count1>nums.length/3){
            ans.add(element1);
        }
        if(vote2>0&&count2>nums.length/3){
            ans.add(element2);
        }
        
        return ans;
    }
}
```



## [Medium] 451. Sort Characters By Frequency

Given a string `s`, sort it in **decreasing order** based on the **frequency** of the characters. The **frequency** of a character is the number of times it appears in the string.

Return *the sorted string*. If there are multiple answers, return *any of them*.

 

**Example 1:**

```
Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
```

**Example 2:**

```
Input: s = "cccaaa"
Output: "aaaccc"
Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
Note that "cacaca" is incorrect, as the same characters must be together.
```

**Example 3:**

```
Input: s = "Aabb"
Output: "bbAa"
Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
```

 

**Constraints:**

- `1 <= s.length <= 5 * 105`
- `s` consists of uppercase and lowercase English letters and digits.



### Solution

```java
class Solution {
public:
    static bool cmp(pair<char, int> p1, pair<char, int> p2){
	    return p1.second > p2.second;
    }
    string frequencySort(string s) {
        map<char,int> m;
        string res;
        for(int i = 0;i < s.size();i++){
            m[s[i]]++;
        }
        vector<pair<char,int>> v;
        for(auto x: m)
        {
            v.push_back({x.first,x.second});
        }
        sort(v.begin(), v.end(), cmp);
        for(auto itr = v.begin(); itr != v.end(); ++itr) {
            for(int k=0;k<itr->second;k++) {
                res+=(itr->first);
            }            
	    }
        return res;
    }

};
```



## [Easy] 492. Construct the Rectangle

A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:

1. The area of the rectangular web page you designed must equal to the given target area.
2. The width `W` should not be larger than the length `L`, which means `L >= W`.
3. The difference between length `L` and width `W` should be as small as possible.

Return *an array `[L, W]` where `L` and `W` are the length and width of the web page you designed in sequence.*

 

**Example 1:**

```
Input: area = 4
Output: [2,2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
```

**Example 2:**

```
Input: area = 37
Output: [37,1]
```

**Example 3:**

```
Input: area = 122122
Output: [427,286]
```

 

**Constraints:**

- `1 <= area <= 107`

### Solution

area除以它一个数，直到能整除，输出商和这个数；这数从area的平方根开始递减，最坏情况降到1；

```java
class Solution {
    public int[] constructRectangle(int area) {
        for(int i = (int)(Math.sqrt(area)); ;i--) {
            if(area%i==0) return new int[]{area/i,i};
        }
    }
}
```



## [Hard] 154. Find Minimum in Rotated Sorted Array II

Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:

- `[4,5,6,7,0,1,4]` if it was rotated `4` times.
- `[0,1,4,4,5,6,7]` if it was rotated `7` times.

Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` that may contain **duplicates**, return *the minimum element of this array*.

You must decrease the overall operation steps as much as possible.

 

**Example 1:**

```
Input: nums = [1,3,5]
Output: 1
```

**Example 2:**

```
Input: nums = [2,2,2,0,1]
Output: 0
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` is sorted and rotated between `1` and `n` times.

 

**Follow up:** This problem is similar to [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/), but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?



### Solution

Bin Search

```java
class Solution {
    public int findMin(int[] nums) {
        int lo = 0,hi=nums.length-1;
        if (nums[lo] < nums[hi]) return nums[lo];
        while(lo<hi) {
            int mid = lo + (hi - lo) / 2;
            if(nums[mid]<nums[hi]){
                hi = mid;
            }else if(nums[mid]>nums[hi]){
                lo = mid+1;
            } else{
                 hi--;
            }
        } 
        return nums[hi];
    }

}
```





## [Easy]496. Next Greater Element I

The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.

You are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.

For each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.

Return *an array* `ans` *of length* `nums1.length` *such that* `ans[i]` *is the **next greater element** as described above.*

 

**Example 1:**

```
Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
```

**Example 2:**

```
Input: nums1 = [2,4], nums2 = [1,2,3,4]
Output: [3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.
```

 

**Constraints:**

- `1 <= nums1.length <= nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 104`
- All integers in `nums1` and `nums2` are **unique**.
- All the integers of `nums1` also appear in `nums2`.

### Solution

单调栈经典例题

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer,Integer> res = nextGreater(nums2);
        int[] resores = new int[nums1.length];
        for(int i =0;i<nums1.length;i++){
            resores[i] = res.getOrDefault(nums1[i], -1);;
        }
        return resores;
    }

    private Map<Integer,Integer> nextGreater(int[] arr){
        Stack<Integer> stack = new Stack<>();
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0;i<arr.length;i++){
            while(!stack.isEmpty() &&stack.peek() <arr[i]){
                 map.put(stack.pop(), arr[i]);
            }
            stack.push(arr[i]);
        }
        return map;
    }
}
```



## [Easy] 226. Invert Binary Tree

Given the `root` of a binary tree, invert the tree, and return *its root*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/invert1-tree.jpg)

```
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
Input: root = [2,1,3]
Output: [2,3,1]
```

**Example 3:**

```
Input: root = []
Output: []
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[0, 100]`.
- `-100 <= Node.val <= 100`



### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode  new_root = root;
        if(root.left!=null||root.right!=null) {
            TreeNode  temp = root.left;
            root.left = root.right;
            root.right = temp;
            root.left = invertTree(root.left);
            root.right = invertTree(root.right);
        }
        return new_root;
    }
}
```



## [Medium] 75. Sort Colors

Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

 

**Example 1:**

```
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

**Example 2:**

```
Input: nums = [2,0,1]
Output: [0,1,2]
```

**Example 3:**

```
Input: nums = [0]
Output: [0]
```

**Example 4:**

```
Input: nums = [1]
Output: [1]
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` is `0`, `1`, or `2`.



### Solution

用的快排，时间$O(nlogn)$, 空间$O(logn)$

```java
class Solution {
    public void sortColors(int[] nums) {
        quickSort(nums,0,nums.length-1);
    }
    private int[] quickSort(int[] num,int left, int right){
        if(left<right){
            int partitionIndex = partition(num,left,right);
            quickSort(num,left,partitionIndex-1);
            quickSort(num,partitionIndex+1,right);
        }
        return num;
    }
    private int partition(int arr[],int left ,int right) {
        int j = left+1;
        for(int k = j;k<=right;k++){
            if(arr[k]<arr[left]){
                swap(arr,k,j);
                j++;
            }
        }
        swap(arr,left,j-1);
        return j-1;
    }
    private int[] swap(int[] arr,int left,int right){
        if(left!=right){
            arr[left] = arr[left]^arr[right];
            arr[right] = arr[left]^arr[right];
            arr[left] = arr[left]^arr[right];
        }
        return arr;
    }
}
```

**Follow up:** Could you come up with a one-pass algorithm using only constant extra space?

我的快排空间复杂度不满足QAQ，针对这道题改一下：

```java
class Solution {
    public void sortColors(int[] nums) {
        if(nums.length<2) return;
        int zero = 0;
        int two = nums.length;
        int i = 0;
        while(i<two){
            if(nums[i]==0){
                swap(nums,zero,i);
                zero++;
                i++;
            } else if(nums[i]==1){
                i++;
            } else{
                two--;
                swap(nums,two,i);
            }
        }
        
        
    }
    private int[] swap(int[] arr,int left,int right){
        if(left!=right){
            arr[left] = arr[left]^arr[right];
            arr[right] = arr[left]^arr[right];
            arr[left] = arr[left]^arr[right];
        }
        return arr;
    }
}
```



## [Hard] 301. Remove Invalid Parentheses

Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return *all the possible results*. You may return the answer in **any order**.

 

**Example 1:**

```
Input: s = "()())()"
Output: ["(())()","()()()"]
```

**Example 2:**

```
Input: s = "(a)())()"
Output: ["(a())()","(a)()()"]
```

**Example 3:**

```
Input: s = ")("
Output: [""]
```

 

**Constraints:**

- `1 <= s.length <= 25`
- `s` consists of lowercase English letters and parentheses `'('` and `')'`.
- There will be at most `20` parentheses in `s`.



### Solution

广度优先搜索

注意到题目中要求最少删除，这样的描述正是广度优先搜索算法应用的场景，并且题目也要求我们输出所有的结果。我们在进行广度优先搜索时每一轮删除字符串中的 11 个括号，直到出现合法匹配的字符串为止，此时进行轮转的次数即为最少需要删除括号的个数。

我们进行广度优先搜索时，每次保存上一轮搜索的结果，然后对上一轮已经保存的结果中的每一个字符串尝试所有可能的删除一个括号的方法，然后将保存的结果进行下一轮搜索。在保存结果时，我们可以利用哈希表对上一轮生成的结果去重，从而提高效率。`

```java
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        List<String> ans = new ArrayList<String>();
        Set<String> currentSet =  new HashSet<String>();
        currentSet.add(s);
        while(true){
            for(String str:currentSet) {
                if(isVaild(str)){
                    ans.add(str);
                }
            }
            if(ans.size()>0){
                return ans;
            }
            Set<String> nextSet =  new HashSet<String>();
            for(String str:currentSet){
                for(int i=0;i<str.length();i++){
                    if(i>0&&str.charAt(i)==str.charAt(i-1)){
                        continue;
                    }
                    if(str.charAt(i)=='('||str.charAt(i)==')') {
                        nextSet.add(str.substring(0,i)+str.substring(i+1));
                    }
                }
            }
            currentSet = nextSet;
        }
    }

    private boolean isVaild(String str ){
        char[] ss = str.toCharArray();
        int count = 0;
        for(char s:ss){
            if(s=='('){
                count++;
            } else if(s==')'){
                count--;
                if(count<0){
                    return false;
                }
            }
        }
        return count == 0;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n \times 2^n)$，其中 $n$ 为字符串的长度。考虑到一个字符串最多可能有 $2^n$ 个子序列，因此时间复杂度为 $O(n \times 2^n)$。
- 空间复杂度：$O(n \times C_n^\frac{n}{2})$，其中 $n$为字符串的长度。我们在进行第 $i$ 轮迭代时，会从原始字符串中删除 $i$个括号，因此第 $i$轮迭代产生的字符串最多有 $C_n^i $个，当$ i = \frac{n}{2}$时组合数最大，此时迭代生成的字符串个数最多，因此空间复杂度为$ O(n \times C_n^\frac{n}{2})$。

## [Medium] 15. 3Sum

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

 

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Example 2:**

```
Input: nums = []
Output: []
```

**Example 3:**

```
Input: nums = [0]
Output: []
```

 

**Constraints:**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`



### Solution

排序后固定一个指针移动两个指针，找到和为0的加到List里面

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i = 0;i<nums.length-2;i++){//i<j<k故i最大也小于length-2
            if(nums[i]>0) break;//因为已排好序，若i对应元素已经大于零了，就没必要继续匹配了
            if(i>0&&nums[i]==nums[i-1]) continue;
            int j=i+1,k=nums.length-1;//j从i的后面开始移动，k从末尾往前移动
            while(j<k){
                int sum = nums[i]+nums[j]+nums[k];
                if(sum<0){
                    while(j<k&&nums[j]==nums[++j]);//若相同继续移动
                } else if (sum>0){
                    while(j<k&&nums[k]==nums[--k]);//k从后往前移
                } else{
                    res.add(new ArrayList(Arrays.asList(nums[i],nums[j],nums[k])));
                    while(j<k&&nums[j]==nums[++j]);//j继续后移
                    while(j<k&&nums[k]==nums[--k]);//k继续前移
                }
            }
        }
        return res;
    }
}
```



## [Medium] 869. Reordered Power of 2

You are given an integer `n`. We reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return `true` *if and only if we can do this so that the resulting number is a power of two*.

 

**Example 1:**

```
Input: n = 1
Output: true
```

**Example 2:**

```
Input: n = 10
Output: false
```

**Example 3:**

```
Input: n = 16
Output: true
```

**Example 4:**

```
Input: n = 24
Output: false
```

**Example 5:**

```
Input: n = 46
Output: true
```

 

**Constraints:**

- `1 <= n <= 109`



### Solution

打表＋词频统计

由于$ 2^{29} < 10^9 < 2^{30}$，因此在$ [1,10^9]$范围内有 $2^0,2^1,\cdots,2^{29}$ 一共$30$ 个$ 2$ 的幂。对这 $30$个数的每个数，我们可以预处理其十进制表示的字符数组中从 $\texttt{0} $到$ \texttt{9}$ 每个字符的出现次数，记在一个长度为$10$ 的数组中，并用一哈希表记录这些数组。对于数字 $n$，我们同样统计其十进制表示的字符数组中从$ \texttt{0}$ 到 $\texttt{9}$每个字符的出现次数，然后去哈希表中查找，若存在则说明 $n$ 可以通过重排得到$ 2 $的幂，否则不能。

```java
class Solution {
    Set<String> set = new HashSet<>();
    public boolean reorderedPowerOf2(int n) {
        init();
        return set.contains(countDigits(n));
    }
    private void init() {
        for(int i = 1;i <= 1e9;i<<=1) {
            set.add(countDigits(i));
        }
    }
    private String countDigits(int n) {
        char[] cnt = new char[10];
        while(n > 0) {
            ++cnt[n % 10];
            n /= 10;
        }
        return new String(cnt);
    }
}
```



## [Hard] 335. Self Crossing

You are given an array of integers `distance`.

You start at point `(0,0)` on an **X-Y** plane and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.

Return `true` if your path crosses itself, and `false` if it does not.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg)

```
Input: distance = [2,1,1,2]
Output: true
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross2-plane.jpg)

```
Input: distance = [1,2,3,4]
Output: false
```

**Example 3:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/selfcross3-plane.jpg)

```
Input: distance = [1,1,1,1]
Output: true
```

 

**Constraints:**

- `1 <= distance.length <= 105`
- `1 <= distance[i] <= 105`



### Solution

没考虑到外卷转内卷的情况，没做出来QAQ

题解：

```java
class Solution {
    public boolean isSelfCrossing(int[] distance) {
        int n=distance.length;
        if(n<4) return false;
        int i = 2;

        //外卷
        while(i<n&&distance[i]>distance[i-2]) i++;

        //如果直接干完了，说明不相交
        if(i==n) return false;

        //外卷转内卷，i-1的长度减i-3的长度
        if(distance[i]>=distance[i-2]-(i<4 ? 0:distance[i-4])){
            distance[i-1] -= i<3 ? 0:distance[i-3];
        }
        //一直内卷
        for(++i;i<n&&distance[i]<distance[i-2];i++);

        //如果i能走完说明不相交，否则相交
        return i!=n;
    }
}
```



<span id="260"></span>

## [Medium] 260. Single Number III

Given an integer array `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in **any order**.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

 

**Example 1:**

```
Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
```

**Example 2:**

```
Input: nums = [-1,0]
Output: [-1,0]
```

**Example 3:**

```
Input: nums = [0,1]
Output: [1,0]
```

 

**Constraints:**

- `2 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- Each integer in `nums` will appear twice, only two integers will appear once.



### Solution

利用异或性质

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        /*if(nums.length==2){
            return nums;
        }*/
        int temp=0;
        for(int n:nums){
            temp^=n;
        }
        int temp2=(~temp+1)&temp;//得到最右边的1
        int temp3=temp;
        for(int n:nums){
            if((n&temp2)>0){//那一位是1的
                temp3^=n;
            }
        }
        return new int[]{temp3,temp3^temp};
    }
}
```



## [Easy] 500. Keyboard Row

Given an array of strings `words`, return *the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below*.

In the **American keyboard**:

- the first row consists of the characters `"qwertyuiop"`,
- the second row consists of the characters `"asdfghjkl"`, and
- the third row consists of the characters `"zxcvbnm"`.

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/keyboard.png)

 

**Example 1:**

```
Input: words = ["Hello","Alaska","Dad","Peace"]
Output: ["Alaska","Dad"]
```

**Example 2:**

```
Input: words = ["omk"]
Output: []
```

**Example 3:**

```
Input: words = ["adsdf","sfd"]
Output: ["adsdf","sfd"]
```

### Solution

```java
class Solution {
    static String[] ss = new String[]{"qwertyuiop","asdfghjkl","zxcvbnm"};
    static int[] hash = new int[26];
    static{
        for(int i=0;i<ss.length;i++){
            for(char c:ss[i].toCharArray()){
                hash[c-'a']=i;
            }
        }
    }
    public String[] findWords(String[] words) {
        List<String> list = new ArrayList<String>();
        for(String word : words){
            int idx = hash[Character.toLowerCase(word.charAt(0))-'a'];
            boolean isVaild = true;
            for(int i=1;i<word.length();i++){
                if(hash[Character.toLowerCase(word.charAt(i))-'a']!=idx){
                    isVaild=false;
                    break;
                }
            }
            if(isVaild){
                list.add(word);
            }
        }
        String[] ans = new String[list.size()];
        for(int i=0;i<list.size();i++){
            ans[i]=list.get(i);
        }
        return ans;
    }
}
```



## [Easy] 575. Distribute Candies

Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.

The doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.

Given the integer array `candyType` of length `n`, return *the **maximum** number of different types of candies she can eat if she only eats* `n / 2` *of them*.

 

**Example 1:**

```
Input: candyType = [1,1,2,2,3,3]
Output: 3
Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.
```

**Example 2:**

```
Input: candyType = [1,1,2,3]
Output: 2
Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.
```

**Example 3:**

```
Input: candyType = [6,6,6,6]
Output: 1
Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.
```

 

**Constraints:**

- `n == candyType.length`
- `2 <= n <= 104`
- `n` is even.
- `-105 <= candyType[i] <= 105`

### Solution

Sort

```java
class Solution {
    public int distributeCandies(int[] candyType) {
        Arrays.sort(candyType);
        int count = 1;
        for(int i=1;i<candyType.length;i++){
            if(candyType[i]>candyType[i-1]){
                count++;
            }
        }
        return Math.min(count,candyType.length/2);
    }
}
```



HashSet

```java
class Solution {
    public int distributeCandies(int[] candyType) {
        Set<Integer> m = new HashSet<>();
        for(int type:candyType){
            m.add(type);
        }
        return(Math.min(m.size(),candyType.length/2));
    }
}
```



## [Medium] 130. Surrounded Regions

Given an `m x n` matrix `board` containing `'X'` and `'O'`, *capture all regions that are 4-directionally surrounded by* `'X'`.

A region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

```
Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
```

**Example 2:**

```
Input: board = [["X"]]
Output: [["X"]]
```

 

**Constraints:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 200`
- `board[i][j]` is `'X'` or `'O'`.

### Solution

dfs ! 从边界调DFS，被遍历到的结点为不被X包围的区域内的，未被遍历到的应是被X阻隔导致DFS无法遍历到的，按题意将其置X

```java
class Solution {
    public void solve(char[][] board) {
        if(board.length==1||board.length==0){
            return;
        }
        
        for(int i=0;i<board.length;i++){
            dfs(board,i,0);
            dfs(board,i,board[0].length-1);
        }
        for(int j=1;j<board[0].length-1;j++){
            dfs(board,0,j);
            dfs(board,board.length-1,j);
        }
        
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]=='F'){
                    board[i][j]='O';
                }else if(board[i][j]=='O'){
                    board[i][j]='X';
                }
            }
        }
    }
    private void dfs(char[][] board,int x,int y){
        if(x>=board.length||x<0||y<0||y>=board[0].length||board[x][y]=='F'||board[x][y]=='X')return;
        board[x][y] = 'F';
        dfs(board,x+1,y);
        dfs(board,x-1,y);
        dfs(board,x,y+1);
        dfs(board,x,y-1);
        return;
    }
}
```



## [Easy] 237. Delete Node in a Linked List

Write a function to **delete a node** in a singly-linked list. You will **not** be given access to the `head` of the list, instead you will be given access to **the node to be deleted** directly.

It is **guaranteed** that the node to be deleted is **not a tail node** in the list.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/01/node1.jpg)

```
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/09/01/node2.jpg)

```
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
```

**Example 3:**

```
Input: head = [1,2,3,4], node = 3
Output: [1,2,4]
```

**Example 4:**

```
Input: head = [0,1], node = 0
Output: [1]
```

**Example 5:**

```
Input: head = [-3,5,-99], node = -3
Output: [5,-99]
```

 

**Constraints:**

- The number of the nodes in the given list is in the range `[2, 1000]`.
- `-1000 <= Node.val <= 1000`
- The value of each node in the list is **unique**.
- The `node` to be deleted is **in the list** and is **not a tail** node



### Solution

因为此结点一定不是尾结点，所以可以复制它的下一结点，逻辑删除它的下一结点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val=node.next.val;
        node.next=node.next.next;
    }
}
```



## [Hard] 980. Unique Paths III

You are given an `m x n` integer array `grid` where `grid[i][j]` could be:

- `1` representing the starting square. There is exactly one starting square.
- `2` representing the ending square. There is exactly one ending square.
- `0` representing empty squares we can walk over.
- `-1` representing obstacles that we cannot walk over.

Return *the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/lc-unique1.jpg)

```
Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
Output: 2
Explanation: We have the following two paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```

**Example 2:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/lc-unique2.jpg)

```
Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
Output: 4
Explanation: We have the following four paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2021/08/02/lc-unique3-.jpg)

```
Input: grid = [[0,1],[2,0]]
Output: 0
Explanation: There is no path that walks over every empty square exactly once.
Note that the starting and ending square can be anywhere in the grid.
```

 

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 20`
- `1 <= m * n <= 20`
- `-1 <= grid[i][j] <= 2`
- There is exactly one starting cell and one ending cell.

### Solution

回溯，递归第一层往4个方向dfs，这4个方向可能的路径和即为解。需要在算出当前层可能解之后将矩阵复原，以供上一层的另外的方向搜索；遇到grid\[x\]\[y\]==-1或者越界直接失败，返回0；遇到2判断zero是否都被遍历完了，若是则找到一条路径，返回1，若否，查找失败，返回0；

```java
class Solution {
    public int uniquePathsIII(int[][] grid) {
        int zero=0,x=0,y=0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j<grid[0].length; j++){
                if(grid[i][j]==0){
                    zero++;
                } else if(grid[i][j]==1){
                    x=i;
                    y=j;
                }
            }
        }
        return dfs(grid, x, y, zero);
    }
    private int dfs(int[][] grid , int x, int y, int zero){
        if(x>=grid.length||y>=grid[0].length||x<0||y<0||grid[x][y]==-1){
            return 0;
        }
        if(grid[x][y]==2){
            return (zero==-1)?1:0;
        }
        grid[x][y]=-1;
        zero--;
        int res = dfs(grid,x+1,y,zero)
                + dfs(grid,x,y+1,zero)
                + dfs(grid,x-1,y,zero)
                + dfs(grid,x,y-1,zero);
        grid[x][y]=0;
        zero++;
        return res;
    }
}
```



## [Easy] 129. Sum Root to Leaf Numbers

You are given the `root` of a binary tree containing digits from `0` to `9` only.

Each root-to-leaf path in the tree represents a number.

- For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.

Return *the total sum of all root-to-leaf numbers*. Test cases are generated so that the answer will fit in a **32-bit** integer.

A **leaf** node is a node with no children.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/num1tree.jpg)

```
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

```
Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 1000]`.
- `0 <= Node.val <= 9`
- The depth of the tree will not exceed `10`.

### Solution

DFS again!

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumNumbers(TreeNode root) {
        return dfs(root,0);
    }
    private int dfs(TreeNode root,int sum){
        if(root==null) return 0;
        sum=sum*10+root.val;
        if(root.left==null&&root.right==null){
            return sum;
        }
        return dfs(root.left,sum)+dfs(root.right,sum);
    }
}
```



## [Easy] 404. Sum of Left Leaves

Given the `root` of a binary tree, return the sum of all left leaves.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/leftsum-tree.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
```

**Example 2:**

```
Input: root = [1]
Output: 0
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 1000]`.
- `-1000 <= Node.val <= 1000`

### Solution

连着几天`DFS`了......今天这个还比较绕。需要算所有左叶子节点的值的和。考虑一个`dfs`函数，首先递归出口是结点为null返回0。结点存在且它是左叶子（标记为true并且左右子结点不存在），令它的值加上左边`dfs`(因为只有向左递归调用才有可能找到左叶子，所以令flag=true)和右边`dfs`得到的值为此函数的返回值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        return dfs(root,false);
    }
    private int dfs(TreeNode root,boolean flag){
        if(root==null) return 0;
        return (flag&&root.left==null&&root.right==null)?root.val:0+dfs(root.left,true)+dfs(root.right,false);
    }
}
```



## [Easy] 367. Valid Perfect Square

Given a **positive** integer *num*, write a function which returns True if *num* is a perfect square else False.

**Follow up:** **Do not** use any built-in library function such as `sqrt`.

 

**Example 1:**

```
Input: num = 16
Output: true
```

**Example 2:**

```
Input: num = 14
Output: false
```

 

**Constraints:**

- `1 <= num <= 2^31 - 1`

### Solution

基于二分查找做

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        long l=0,r=num;
        while(l<r){
           long mid = (l+r+1)>>1;
           if(mid*mid<=num) l=mid;
           else r=mid-1; 
        }
        return r*r==num;
    }
}
```



## [Easy] 441. Arranging Coins

You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `ith` row has exactly `i` coins. The last row of the staircase **may be** incomplete.

Given the integer `n`, return *the number of **complete rows** of the staircase you will build*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/arrangecoins1-grid.jpg)

```
Input: n = 5
Output: 2
Explanation: Because the 3rd row is incomplete, we return 2.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg)

```
Input: n = 8
Output: 3
Explanation: Because the 4th row is incomplete, we return 3.
```

 

**Constraints:**

- `1 <= n <= 231 - 1`

### Solution

暴力

```java
class Solution {
    public int arrangeCoins(int n) {
        int i=1;
        while(n>0){
            i++;
            n=n-i;
        }
        return i-1;
    }
}
```

数学归纳

```java
class Solution {
    public int arrangeCoins(int n) {
        return (int) (Math.sqrt(2 * (long) n + 0.25) - 0.5);
    }
}
```



## [Medium] 260

[Go to](#260)



## [Easy] 268. Missing Number

Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return *the only number in the range that is missing from the array.*

 

**Example 1:**

```
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
```

**Example 2:**

```
Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
```

**Example 3:**

```
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
```

**Example 4:**

```
Input: nums = [0]
Output: 1
Explanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 104`
- `0 <= nums[i] <= n`
- All the numbers of `nums` are **unique**.

 

**Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?

### Solution

首先想到数学法,  时间O(n) 空间O(1)

```java
class Solution {
    public int missingNumber(int[] nums) {
        int sum1=0,n=nums.length;
        for(int i=0;i<n;i++){
            sum1+=nums[i];
        }
        return n*(n+1)/2-sum1;
    }
}
```

还能用异或做，时间O(n) 空间O(1)

```java
class Solution {
    public int missingNumber(int[] nums) {
        int temp=nums[0],n=nums.length;
        for(int i=1;i<n;i++) temp^=nums[i];
        for(int i=0;i<=n;i++) temp^=i;
        return temp;
    }
}
```



## [Hard] 23. Merge k Sorted Lists

You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

*Merge all the linked-lists into one sorted linked-list and return it.*

 

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

 

**Constraints:**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` is sorted in **ascending order**.
- The sum of `lists[i].length` won't exceed `10^4`.

### Solution

归并, 硬搞

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length<=0) return null;
        return process(lists, 0, lists.length - 1);
    }
    private static ListNode process(ListNode[] list ,int l, int r) {
        if(l==r){
            return list[l];
        }
        int mid =  (l + r) >> 1;
        ListNode L=process(list,l,mid);
        ListNode R=process(list,mid + 1,r);
        return merge(L,R);
    }
    private static ListNode merge(ListNode a, ListNode b) {
        ListNode fuck = new ListNode(-1);
        ListNode cur = fuck;
        while(a != null && b != null) {
            if(a.val < b.val) {
                cur.next = a;
                a = a.next;
            } else {
                cur.next = b;
                b = b.next;
            }
            cur = cur.next;
        }
        if(a != null) {
            cur.next = a;
        }
        if(b != null) {
            cur.next = b;
        }
        return fuck.next;
    }
}
```



## [Easy] 88. Merge Sorted Array

You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.

**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.

The final sorted array should not be returned by the function, but instead be *stored inside the array* `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.

 

**Example 1:**

```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
```

**Example 2:**

```
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
```

**Example 3:**

```
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
```

 

**Constraints:**

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-109 <= nums1[i], nums2[j] <= 109`

 

**Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?

### Solution

练习归并，时间空间都是O(m+n)

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] temp = new int[m+n];
        if(n==0) return;
        int p1=0,p2=0,i=0;
        if(m==0){
            for(int f:nums2){
                nums1[i++]=f;
            }
            return;
        }
        while(p1<m&&p2<n){
            temp[i++] = nums1[p1]<nums2[p2]?nums1[p1++]:nums2[p2++];
        }
        while(p1<m){
            temp[i++] = nums1[p1++];
        }
        while(p2<n){
            temp[i++] = nums2[p2++];
        }
        i=0;
        for(int k:temp){
            nums1[i++]=k;
        }
    }
}
```



## [Medium] 43. Multiply Strings

Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.

**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.

 

**Example 1:**

```
Input: num1 = "2", num2 = "3"
Output: "6"
```

**Example 2:**

```
Input: num1 = "123", num2 = "456"
Output: "56088"
```

 

**Constraints:**

- `1 <= num1.length, num2.length <= 200`
- `num1` and `num2` consist of digits only.
- Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.

### Solution

```java
class Solution {
    public String multiply(String num1, String num2) {
        int n1=num1.length();
        int n2=num2.length();
        if(n1<=0||n2<=0) return "";
        int[] temp = new int[n1+n2];//临时数组
        for(int i=n1-1;i>=0;--i) {
            for(int j=n2-1;j>=0;--j) {
                int fuck = (num1.charAt(i)-'0')*(num2.charAt(j)-'0');
                fuck+=temp[i+j+1];//加上低位判断是否产生进位
                temp[i+j]+=fuck/10;//进位
                temp[i+j+1]=fuck%10;
            }
        }
        StringBuilder sb = new StringBuilder();
        int index=0;
        while(index<temp.length-1&&temp[index]==0){//去掉Leading 0s
            index++;
        }
        for(;index<temp.length;index++){//拷贝到sb里
            sb.append(temp[index]);
        }
        return sb.toString();
    }
}
```



## [Easy] 598. Range Addition II

You are given an `m x n` matrix `M` initialized with all `0`'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means `M[x][y]` should be incremented by one for all `0 <= x < ai` and `0 <= y < bi`.

Count and return *the number of maximum integers in the matrix after performing all the operations*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/ex1.jpg)

```
Input: m = 3, n = 3, ops = [[2,2],[3,3]]
Output: 4
Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.
```

**Example 2:**

```
Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]
Output: 4
```

**Example 3:**

```
Input: m = 3, n = 3, ops = []
Output: 9
```

 

**Constraints:**

- `1 <= m, n <= 4 * 104`
- `0 <= ops.length <= 104`
- `ops[i].length == 2`
- `1 <= ai <= m`
- `1 <= bi <= n`

### Solution

脑筋急转弯，跟矩阵无关，处理下标即可

```java
class Solution {
    public int maxCount(int m, int n, int[][] ops) {
        for(int[] op : ops){
            m=Math.min(m,op[0]);
            n=Math.min(n,op[1]);
        }
        return m*n;
    }
}
```



## [Medium] 96. Unique Binary Search Trees

Given an integer `n`, return *the number of structurally unique **BST'**s (binary search trees) which has exactly* `n` *nodes of unique values from* `1` *to* `n`.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/uniquebstn3.jpg)

```
Input: n = 3
Output: 5
```

**Example 2:**

```
Input: n = 1
Output: 1
```

 

**Constraints:**

- `1 <= n <= 19`

### Solution

动态规划，$dp(n) = dp(0)\times dp(n-1) +dp(1)\times dp(n-2) + dp(2)\times dp(n-3) + ...... + dp(n-3)\times dp(2) +dp(n-2)\times dp(1) + dp(n-1)\times dp(0)$

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[i-j]*dp[j-1];
            }
        }
        return dp[n];
    }
}
```



## [Medium] 299. Bulls and Cows

You are playing the **[Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows)** game with your friend.

You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:

- The number of "bulls", which are digits in the guess that are in the correct position.
- The number of "cows", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.

Given the secret number `secret` and your friend's guess `guess`, return *the hint for your friend's guess*.

The hint should be formatted as `"xAyB"`, where `x` is the number of bulls and `y` is the number of cows. Note that both `secret` and `guess` may contain duplicate digits.

 

**Example 1:**

```
Input: secret = "1807", guess = "7810"
Output: "1A3B"
Explanation: Bulls are connected with a '|' and cows are underlined:
"1807"
  |
"7810"
```

**Example 2:**

```
Input: secret = "1123", guess = "0111"
Output: "1A1B"
Explanation: Bulls are connected with a '|' and cows are underlined:
"1123"        "1123"
  |      or     |
"0111"        "0111"
Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.
```

**Example 3:**

```
Input: secret = "1", guess = "0"
Output: "0A0B"
```

**Example 4:**

```
Input: secret = "1", guess = "1"
Output: "1A0B"
```

 

**Constraints:**

- `1 <= secret.length, guess.length <= 1000`
- `secret.length == guess.length`
- `secret` and `guess` consist of digits only.

### Solution

我不觉得简单的简单模拟题

```java
class Solution {
    public String getHint(String secret, String guess) {
        int[] cnt1 = new int[10], cnt2 = new int[10];
        int a=0,b=0;
        for(int i=0;i<secret.length();i++) {
            int c1=secret.charAt(i)-'0',c2=guess.charAt(i)-'0';
            if(c1==c2) {
                a++;
            } else {
                cnt1[c1]++;
                cnt2[c2]++;
            }
        }
        for(int i=0;i<10;i++) b+=Math.min(cnt1[i],cnt2[i]);
        return a+"A"+b+"B";
    }
}
```



## [Easy] 70. Climbing Stairs

You are climbing a staircase. It takes `n` steps to reach the top.

Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

 

**Example 1:**

```
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```

**Example 2:**

```
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

 

**Constraints:**

- `1 <= n <= 45`

### Solution

```java
class Solution {
    public int climbStairs(int n) {
        if(n<=3) return n;
        int a=2,b=3,c=a+b;
        for(int i=4;i<=n;i++){
            c=a+b;
            a=b;
            b=c;
        }
        return c;
    }
}
```



## [Easy] 746. Min Cost Climbing Stairs

You are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index `0`, or the step with index `1`.

Return *the minimum cost to reach the top of the floor*.

 

**Example 1:**

```
Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.
```

**Example 2:**

```
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.
```

 

**Constraints:**

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

### Solution

用$dp[i]$表示到第$i$级台阶的最小代价

状态转移方程： $dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1])$

由于到当前台阶的代价只与它前两级的代价有关，所以可以只用三个变量

初值：$dp[0]=dp[1]=0;$

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int a=0,b=0,c=0;
        for(int i=2;i<=cost.length;i++){
            c=Math.min(a+cost[i-2],b+cost[i-1]);
            a=b;
            b=c;
        }
        return c;
    }
}
```

## [Hard] 1178. Number of Valid Words for Each Puzzle

With respect to a given `puzzle` string, a `word` is *valid* if both the following conditions are satisfied:

- `word` contains the first letter of `puzzle`.

- For each letter in `word`, that letter is in `puzzle`.

  - For example, if the puzzle is `"abcdefg"`, then valid words are `"faced"`, `"cabbage"`, and `"baggage"`, while
- invalid words are `"beefed"` (does not include `'a'`) and `"based"` (includes `'s'` which is not in the puzzle).

Return *an array* `answer`*, where* `answer[i]` *is the number of words in the given word list* `words` *that is valid with respect to the puzzle* `puzzles[i]`. 

**Example 1:**

```
Input: words = ["aaaa","asas","able","ability","actt","actor","access"], puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
Output: [1,1,3,2,4,0]
Explanation: 
1 valid word for "aboveyz" : "aaaa" 
1 valid word for "abrodyz" : "aaaa"
3 valid words for "abslute" : "aaaa", "asas", "able"
2 valid words for "absoryz" : "aaaa", "asas"
4 valid words for "actresz" : "aaaa", "asas", "actt", "access"
There are no valid words for "gaswxyz" cause none of the words in the list contains letter 'g'.
```

**Example 2:**

```
Input: words = ["apple","pleas","please"], puzzles = ["aelwxyz","aelpxyz","aelpsxy","saelpxy","xaelpsy"]
Output: [0,1,3,2,0]
```

**Constraints:**

- `1 <= words.length <= 105`
- `4 <= words[i].length <= 50`
- `1 <= puzzles.length <= 104`
- `puzzles[i].length == 7`
- `words[i]` and `puzzles[i]` consist of lowercase English letters.
- Each `puzzles[i] `does not contain repeated characters.



### Solution 

憋不出来的Hard.......

$HashMap$和位运算

`a >> b & 1` 代表检查 a 的第 b 位是否为 1，有两种可能性 0 或者 1

`a += 1 << b` 代表将 a 的第 b 位设置为 1 (当第 b 位为 0 的时候适用)

如不想写对第 b 位为 0 的前置判断，`a += 1 << b` 也可以改成 `a |= 1 << b`

```java
class Solution {
    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {
        Map<Integer , Integer> map = new HashMap<>();
        for(String w : words) {
            int t = getBin(w);
            map.put(t, map.getOrDefault(t, 0) + 1);
        }
        List<Integer> ans = new ArrayList<Integer>();
        for(String p : puzzles) ans.add(getCnt(map, p));
        return ans;
    }
    // 统计string的字符，返回一个26位的二进制数（其实是32位，只用26位），表示每个字母是否出现，出现的位置标1
    private static int getBin(String str) {
        char[] cs = str.toCharArray();
        int res = 0;
        for(char c : cs) {
            // 每一位字符所对应二进制数字中哪一位
            int t = c - 'a';
            // 不重复地记录字符
            if((res >> t & 1) == 0) res += 1 << t; 
        }
        return res;
    }
    private static int getCnt(Map<Integer, Integer> map, String str) {
        int ans = 0;
        int m = str.length();
        char[] cs = str.toCharArray();
        // 首字母在二进制数值中的位置
        int first = cs[0] - 'a';t
        for(int i = 0; i < (1 << (m - 1)); i++) {
            // t 代表了当前可能的谜底。先将首字母提取出来
            int t = 1 << first;
            // 枚举「首个字母」之后的每一位
            for(int j = 1; j < m; j++) {
                // 如果当前位为 1，代表该位置要保留，将该位置的字母追加到谜底 t 中
                if((i >> (j-1) & 1) == 1) t += 1 << (cs[j]-'a');
            }
            // 查询这样的词出现了多少次
            if(map.containsKey(t)) ans += map.get(t);
        }
        return ans;
    }
}
```



## [Medium] 198. House Robber  

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

 

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 2:**

```
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
```

 

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

### Solution

  动态规划！

  考虑当前这家抢还是不抢，抢的话获得的\$是当前这家加上考虑从它下下家开始能获得的最大金额，不抢的话获得的是从它下一家开始考虑能获得的最大金额。

  写成状态转移方程：

  $dp[i] = max(dp[i+1], dp[i+2]+money[i])$

```java
class Solution {
    public int rob(int[] nums) {
        int[] dp = new int[nums.length+2];
        for(int i=nums.length-1;i>=0;i--) {
            dp[i] = Math.max(dp[i+1],dp[i+2]+nums[i]);
        }
        return dp[0];
    }
}
```

空间优化：

```java
class Solution {
    public int rob(int[] nums) {
        int pre = 0, cur = 0;
        for(int num : nums) {
            int max = Math.max(cur, pre + num);
            pre = cur;
            cur = max;
        }
        return cur;
    }
}
```



## [Medium] 213. House Robber II

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

 

**Example 1:**

```
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
```

**Example 2:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 3:**

```
Input: nums = [1,2,3]
Output: 3
```

 

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

### Solution

环形的，考虑`抢第一家不抢最后一家`和`抢最后一家不抢第一家`还有`第一家最后一家都不抢`（这种情况包括在抢最后一家不抢第一家里）

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==1) return nums[0];
        return Math.max(robRange(nums, 0, nums.length - 2) , robRange(nums, 1, nums.length-1) );
    }
    private static int robRange(int[] nums, int start, int end) {
        int pre = 0;
        int cur = 0;
        for(int i = start;i <= end; i++) {
            int temp = Math.max(cur, nums[i] + pre);
            pre = cur;
            cur = temp;
        }
        return cur;
    }
}
```



## [Medium] 740. Delete and Earn

You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:

- Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.

Return *the **maximum number of points** you can earn by applying the above operation some number of times*.

 

**Example 1:**

```
Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
```

**Example 2:**

```
Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.
```

 

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `1 <= nums[i] <= 104`

### Solution

可以转化为打家劫舍问题。

Delete 3 可以得到3 点，并且失去Delete 2 和4 的机会，但是还能继续Delete 3 获得3 点。

根据这个性质设计另一个数组，储存所有相同数值数的和，比如对[2,2,3,3,4]设计一个[0,0,4,6,4]

得到的数组就可以按照打家劫舍问题来做了（相邻的点数不能同时获得）

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int max = 0;
        for(int num : nums) {
            if(num>max) max = num;
        }
        int[] temp = new int[max+1];
        for(int num : nums) {
            temp[num] += num;
        }
        return rob(temp);
    }
    private static int rob(int[] nums) {
        int pre = 0;
        int cur = 0;
        for(int num : nums) {
            int temp = Math.max(cur, pre + num);
            pre = cur;
            cur = temp;
        }
        return cur;
    }
}
```



## [Easy] 495. Teemo Attacking

Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly `duration` seconds. More formally, an attack at second `t` will mean Ashe is poisoned during the **inclusive** time interval `[t, t + duration - 1]`. If Teemo attacks again **before** the poison effect ends, the timer for it is **reset**, and the poison effect will end `duration` seconds after the new attack.

You are given a **non-decreasing** integer array `timeSeries`, where `timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]`, and an integer `duration`.

Return *the **total** number of seconds that Ashe is poisoned*.

 

**Example 1:**

```
Input: timeSeries = [1,4], duration = 2
Output: 4
Explanation: Teemo's attacks on Ashe go as follows:
- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.
Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.
```

**Example 2:**

```
Input: timeSeries = [1,2], duration = 2
Output: 3
Explanation: Teemo's attacks on Ashe go as follows:
- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.
Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.
```

 

**Constraints:**

- `1 <= timeSeries.length <= 104`
- `0 <= timeSeries[i], duration <= 107`
- `timeSeries` is sorted in **non-decreasing** order.

### Solution

```java
class Solution {
    public int findPoisonedDuration(int[] ts, int d) {
        int ans=0,pre=-1;
        for(int t:ts){
            ans+=pre<t?d:t+d-1-pre;
            pre = t+d-1;
        }
        return ans;
    }
}
```



## [Medium] 122. Best Time to Buy and Sell Stock II

You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

On each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.

Find and return *the **maximum** profit you can achieve*.

 

**Example 1:**

```
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
```

**Example 2:**

```
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
```

**Example 3:**

```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.
```

 

**Constraints:**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

### Solution

Easy solution:

```java
class Solution {
    public int maxProfit(int[] prices) {
        int sum = 0;
        for(int i = 1; i < prices.length; i++) sum += (prices[i] - prices[i - 1] > 0 )?prices[i] - prices[i - 1]:0;
        return sum;
    }
}
```

DP solution:

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int s0 = 0, s1 = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            int temp = s0;
            s0 = Math.max(s0, s1 + prices[i]);
            s1 = Math.max(s1, temp - prices[i]);
        }
        return s0;
    }
}
```

## [Easy] 53. Maximum Subarray 

Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return *its sum*.

A **subarray** is a **contiguous** part of an array.

 

**Example 1:**

```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

**Example 2:**

```
Input: nums = [1]
Output: 1
```

**Example 3:**

```
Input: nums = [5,4,-1,7,8]
Output: 23
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

### Solution

$dp$数组记录下以`nums[i]`结尾的最大子数组和

状态转移方程推导：`dp[i]` 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        for(int i= 1; i < nums.length; i++) {
            dp[i] = Math.max(nums[i], nums[i]+dp[i-1]);
        }
        int max = dp[0];
        for(int i = 0; i < dp.length; i++) {
            max=Math.max(dp[i], max);
        }
        return max;
    }
}
```

空间优化

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int dp_0 = nums[0];
        int dp_1 = 0;
        int max = dp_0;
        for(int i= 1; i < nums.length; i++) {
            dp_1 = Math.max(nums[i], nums[i]+dp_0);
            dp_0 = dp_1;
            max = Math.max(dp_1,max);
        }
        
        return max;
    }
}
```



## [Medium] 918. Maximum Sum Circular Subarray

Given a **circular integer array** `nums` of length `n`, return *the maximum possible sum of a non-empty **subarray** of* `nums`.

A **circular array** means the end of the array connects to the beginning of the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`.

A **subarray** may only include each element of the fixed buffer `nums` at most once. Formally, for a subarray `nums[i], nums[i + 1], ..., nums[j]`, there does not exist `i <= k1`, `k2 <= j` with `k1 % n == k2 % n`.

 

**Example 1:**

```
Input: nums = [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3
```

**Example 2:**

```
Input: nums = [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10
```

**Example 3:**

```
Input: nums = [3,-1,2,-1]
Output: 4
Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4
```

**Example 4:**

```
Input: nums = [3,-2,2,-3]
Output: 3
Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3
```

**Example 5:**

```
Input: nums = [-2,-3,-1]
Output: -1
Explanation: Subarray [-1] has maximum sum -1
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`

### Solution

最大子序和在两边：全部的和减去中间求得的最小子序和

最大子序和在中间：和53题一样

```java
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int dp_1 = nums[0];
        int dp_11 = nums[0];
        int min = dp_1;
        int max = dp_1;
        int sum = dp_1;
        for(int i = 1; i < nums.length; i++) {
            dp_1 =nums[i]<(dp_1+nums[i])?nums[i]:(dp_1+nums[i]);
            dp_11 = nums[i]>(dp_11+nums[i])?nums[i]:(dp_11+nums[i]);
            min = min< dp_1?min:dp_1;
            max = max>dp_11?max:dp_11;
            sum+=nums[i];
        }
        if(max<0)return max;
        return max>(sum-min)?max:sum-min;
    }
}
```



## [Medium] 55. Jump Game

You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.

Return `true` *if you can reach the last index, or* `false` *otherwise*.

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
```

**Constraints:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`



### Solution

贪心！看最多能跳到哪儿，如果最远能超过数组的last index（注意是last index），返回true

```java
class Solution {
    public boolean canJump(int[] nums) {
        int max = 0;
        for(int i = 0; i < nums.length - 1; i++) {
            max = max > nums[i] + i ? max : nums[i] + i;
            if(max <= i) {
                return false;
            }
        }
        return max >= nums.length-1;
    }
}
```



## [Medium] 45. Jump Game II

Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

You can assume that you can always reach the last index.

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [2,3,0,1,4]
Output: 2
```

**Constraints:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`

### Solution

从0开始贪心到能到达的最大位置，这个位置与某一次循环的下标重合时，说明跳了一次计数器加一

```java
class Solution {
    public int jump(int[] nums) {
        int max = 0, end = 0, ans = 0;
        for(int i = 0; i < nums.length - 1; i++) {
            max = max > nums[i] + i ? max : nums[i] + i;
            if(end == i) {
                ans++;
                end = max;
            }
        }
        return ans;
    }
}
```



## [Medium] 152. Maximum Product Subarray

Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return *the product*.

It is **guaranteed** that the answer will fit in a **32-bit** integer.

A **subarray** is a contiguous subsequence of the array.

**Example 1:**

```
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

**Example 2:**

```
Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `-10 <= nums[i] <= 10`
- The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.



### Solution

记录乘积最大值和乘积最小值，遇到负数，两数交换，保证无论正负，在计算乘积最大值时得到的一定是最大的

```java
class Solution {
    public int maxProduct(int[] nums) {
        int pre = nums[0],pre1 = nums[0],max=nums[0];
        for(int i=1;i<nums.length;i++) {
            if(nums[i]<0){
                pre = pre^pre1;
                pre1 = pre^pre1;
                pre = pre^pre1;
            }
            pre = nums[i]>nums[i]*pre?nums[i]:nums[i]*pre;
            pre1 = nums[i]<nums[i]*pre1?nums[i]:nums[i]*pre1;
            max = max>pre?max:pre;
        }
        return max;
    }
}
```



## [Medium] 1567. Maximum Length of Subarray With Positive Product

Given an array of integers `nums`, find the maximum length of a subarray where the product of all its elements is positive.

A subarray of an array is a consecutive sequence of zero or more values taken out of that array.

Return *the maximum length of a subarray with positive product*.

 

**Example 1:**

```
Input: nums = [1,-2,-3,4]
Output: 4
Explanation: The array nums already has a positive product of 24.
```

**Example 2:**

```
Input: nums = [0,1,-2,-3,-4]
Output: 3
Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.
Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.
```

**Example 3:**

```
Input: nums = [-1,-2,-3,0,1]
Output: 2
Explanation: The longest subarray with positive product is [-1,-2] or [-2,-3].
```

**Example 4:**

```
Input: nums = [-1,2]
Output: 1
```

**Example 5:**

```
Input: nums = [1,2,3,5,-6,4,0,10]
Output: 4
```

 

**Constraints:**

- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

### Solution

![image](https://user-images.githubusercontent.com/59683877/141608731-2552c8b3-2b9c-45f8-8483-382c912cb264.png)


```java
class Solution {
    public int getMaxLen(int[] nums) {
        int pos = nums[0]>0?1:0;
        int neg = nums[0]<0?1:0;
        int max = pos;
        for(int i=1;i<nums.length;i++) {
            if(nums[i]>0) {
                pos++;
                neg = neg>0?neg+1:0;
            } else if(nums[i]<0) {
                int temp = pos+1;
                pos = neg>0?neg+1:0;
                neg = temp;
            } else {
                neg = 0;
                pos = 0;
            }
            max = max>pos ? max:pos;
        }
        return max;
    }
}
```



## [Medium] 739. Daily Temperatures

单调栈效果贼拉，复盘一下

[见Data_Structure](./2021-9-15-Data_Structure.md/# LeetCode 739 Daily Temperatures)

最优解：

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int[] ans = new int[temperatures.length];
        for(int i=temperatures.length-1;i>=0;i--) {
            int j = i+1;
            while(j<temperatures.length) {
                if(temperatures[j]>temperatures[i]) {
                    ans[i] = j-i;
                    break;
                } else if(ans[j] == 0) {
                    break;
                } else{
                    j += ans[j];
                }
            }
        }
        return ans;
    }
}
```



## [Medium] 1014. Best Sightseeing Pair

You are given an integer array `values` where values[i] represents the value of the `ith` sightseeing spot. Two sightseeing spots `i` and `j` have a **distance** `j - i` between them.

The score of a pair (`i < j`) of sightseeing spots is `values[i] + values[j] + i - j`: the sum of the values of the sightseeing spots, minus the distance between them.

Return *the maximum score of a pair of sightseeing spots*. 

**Example 1:**

```
Input: values = [8,1,5,2,6]
Output: 11
Explanation: i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11
```

**Example 2:**

```
Input: values = [1,2]
Output: 2
```

**Constraints:**

- `2 <= values.length <= 5 * 104`
- `1 <= values[i] <= 1000`

### Solution

`values[i] + values[j] + i - j` 拆为 `(values[i] + i) + (values[j] - j)`又要满足`i<j`,把问题转化为求 `[0,j-1]` 中`values[i] + i`的最大值`preMax`, `preMax + values[j] - j`能达到的最大值即是问题的解。

```java
class Solution {
    public int maxScoreSightseeingPair(int[] values) {
        int preMax = values[0], ans = 0;
        for(int i = 1; i< values.length; i++) {
            ans = ans > preMax + values[i] - i ? ans : preMax + values[i] - i;
            preMax = preMax > values[i] + i ? preMax : values[i] + i;
        }
        return ans;
    }
}
```



## [Easy] 121. Best Time to Buy and Sell Stock

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

Return *the maximum profit you can achieve from this transaction*. If you cannot achieve any profit, return `0`.

**Example 1:**

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

**Example 2:**

```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
```

**Constraints:**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

## Solution

> maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell 
>

选一天买入，再未来某一天卖出，使利益最大化，只需要至多一次买入，一次卖出，卖出日需在买入日之后；

站在`i`位置往前看，我希望自己是在`i`之前位置中**价格最小时买入**的，这样我在`i`位置卖出能获得的最大利益可以算出来，这时的利益不一定比前几天卖出获得的利益大，所以得维护一个变量记录利益最大值，如果`i`位置卖出的最大利益大于这个值就更新它。

对`i`位置的价格来说，可将问题转化为：

​    令`[0,i-1]`范围上最小值为`preMin`, 求`prices[i] - preMin`的最大值 ；

只需一次遍历更新最大值，遍历结束得到的即是整个数组上两数字最大的差。

```java
class Solution {
    public int maxProfit(int[] prices) {
        int preMin = prices[0], ans = 0;
        for(int i = 1; i < prices.length; i++) {
            ans = ans > prices[i] - preMin ? ans : prices[i] - preMin;
            preMin = preMin > prices[i] ? prices[i] : preMin;
        }
        return ans;
    }
}
```
## [Medium] 1286. Iterator for Combination

Design the `CombinationIterator` class:

- `CombinationIterator(string characters, int combinationLength)` Initializes the object with a string `characters` of **sorted distinct** lowercase English letters and a number `combinationLength` as arguments.
- `next()` Returns the next combination of length `combinationLength` in **lexicographical order**.
- `hasNext()` Returns `true` if and only if there exists a next combination.

**Example 1:**

```
Input
["CombinationIterator", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[["abc", 2], [], [], [], [], [], []]
Output
[null, "ab", true, "ac", true, "bc", false]

Explanation
CombinationIterator itr = new CombinationIterator("abc", 2);
itr.next();    // return "ab"
itr.hasNext(); // return True
itr.next();    // return "ac"
itr.hasNext(); // return True
itr.next();    // return "bc"
itr.hasNext(); // return False
```

**Constraints:**

- `1 <= combinationLength <= characters.length <= 15`
- All the characters of `characters` are **unique**.
- At most `104` calls will be made to `next` and `hasNext`.
- It's guaranteed that all calls of the function `next` are valid.

### Solution

回溯查出所有符合的子串

```java
class CombinationIterator {

    private static Queue<String> queue;
    
    public CombinationIterator(String characters, int combinationLength) {
        queue = new LinkedList<>();
        backtracking(characters,combinationLength,new StringBuilder(),0);
    }
    
    public String next() {
        return queue.poll();
    }
    
    public boolean hasNext() {
        return !queue.isEmpty();
    }
    
    private static void backtracking(String chs,int len,StringBuilder sb,int index) {
        if(sb.length()==len) {//出口
            queue.add(sb.toString());//结果扔队列里去
            return;
        }
        for(int i = index; i < chs.length(); i++) {
            sb.append(chs.charAt(i)); //扩展
            backtracking(chs,len,sb,i+1);//dfs查
            sb.deleteCharAt(sb.length()-1);//恢复现场
        }
    }
}

/**
 * Your CombinationIterator object will be instantiated and called as such:
 * CombinationIterator obj = new CombinationIterator(characters, combinationLength);
 * String param_1 = obj.next();
 * boolean param_2 = obj.hasNext();
 */
```



## [Medium] 309. Best Time to Buy and Sell Stock with Cooldown 

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:

- After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).

**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

**Example 1:**

```
Input: prices = [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
```

**Example 2:**

```
Input: prices = [1]
Output: 0
```

**Constraints:**

- `1 <= prices.length <= 5000`
- `0 <= prices[i] <= 1000`

### Solution

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length<2) return 0;
        int s0 = -prices[0];
        int s1 = 0;
        int s2 = 0;
        for(int i = 1; i < prices.length; i++) {
            int news0 = Math.max(s0,s2-prices[i]);
            int news1 = s0+prices[i];
            int news2 = Math.max(s1,s2);
            s0 = news0;
            s1 = news1;
            s2 = news2;
        }
        return Math.max(s1,s2);
    }
}
```



## [Medium] 714. Best Time to Buy and Sell Stock with Transaction Fee  

You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.

Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.

**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

**Example 1:**

```
Input: prices = [1,3,2,8,4,9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```

**Example 2:**

```
Input: prices = [1,3,7,5,10,3], fee = 3
Output: 6
```

**Constraints:**

- `1 <= prices.length <= 5 * 104`
- `1 <= prices[i] < 5 * 104`
- `0 <= fee < 5 * 104`



### Solution

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int s0 = Integer.MIN_VALUE;
        int s1 = 0;
        for(int i = 0; i < prices.length; i++) {
            int temp = s0;
            s0 = Math.max(s0, s1-prices[i]-fee);
            s1 = Math.max(s1, temp+prices[i]);
        }
        return s1;
    }
}
```



## [Medium] 368. Largest Divisible Subset

Given a set of **distinct** positive integers `nums`, return the largest subset `answer` such that every pair `(answer[i], answer[j])` of elements in this subset satisfies:

- `answer[i] % answer[j] == 0`, or
- `answer[j] % answer[i] == 0`

If there are multiple solutions, return any of them.

**Example 1:**

```
Input: nums = [1,2,3]
Output: [1,2]
Explanation: [1,3] is also accepted.
```

**Example 2:**

```
Input: nums = [1,2,4,8]
Output: [1,2,4,8]
```

**Constraints:**

- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 2 * 109`
- All the integers in `nums` are **unique**.

### Solution

动态规划，和最长递增子序列很像。

```java
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        int n = nums.length;
        List<Integer> res = new ArrayList<>();
        if(nums==null||n<=0) return res;
        Arrays.sort(nums);
        if(n==0) {
            res.add(nums[0]);
            return res;
        }
        int[] pre = new int[n];//记录从何转移来
        int[] dp = new int[n];//记录最大长度
        Arrays.fill(dp, 1);
        for(int i = 0; i < n; i++) {
            pre[i] = i;
        }
        int maxLen = 0, maxIndex = 0;
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < i; j++) {
                if(nums[i]%nums[j]==0 && dp[j] + 1 > dp[i]) { //找到符合条件的j
                    dp[i] = dp[j] + 1; 
                    //取最大值，代表希望找到nums[i]为结尾最长的乘除子集，需要将nums[i]接到nums[j]后面
                    pre[i] = j;//记录i转移到j状态
                }//else dp[i] = 1;在i之前找不到符合条件的j，只能自己作为整除子集的第一个数
            }
            if(dp[i]>maxLen) {
                maxLen = dp[i];
                maxIndex = i;
            }
        }
        int i = maxIndex;
        while(pre[i]!=i) {
            res.add(nums[i]);
            i = pre[i];
        }
        res.add(nums[i]);
        return res;
    }
}
```



## [Medium] 139. Word Break

Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.

**Note** that the same word in the dictionary may be reused multiple times in the segmentation.

**Example 1:**

```
Input: s = "leetcode", wordDict = ["leet","code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
```

**Example 2:**

```
Input: s = "applepenapple", wordDict = ["apple","pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
```

**Example 3:**

```
Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
Output: false
```

**Constraints:**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` and `wordDict[i]` consist of only lowercase English letters.
- All the strings of `wordDict` are **unique**.

### Solution

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        boolean[] dp = new boolean[len+1];
        dp[0] = true;
        Set<String> wordDictSet = new HashSet(wordDict);
        for(int i = 1; i <= len; i++) {
            for(int j = 0; j < i; j++) {
                if(dp[j]&&wordDictSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[len];
    }
}
```



## [Easy] 566. Reshape the Matrix

In MATLAB, there is a handy function called `reshape` which can reshape an `m x n` matrix into a new one with a different size `r x c` keeping its original data.

You are given an `m x n` matrix `mat` and two integers `r` and `c` representing the number of rows and the number of columns of the wanted reshaped matrix.

The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.

If the `reshape` operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/reshape1-grid.jpg)

```
Input: mat = [[1,2],[3,4]], r = 1, c = 4
Output: [[1,2,3,4]]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg)

```
Input: mat = [[1,2],[3,4]], r = 2, c = 4
Output: [[1,2],[3,4]]
```

**Constraints:**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 100`
- `-1000 <= mat[i][j] <= 1000`
- `1 <= r, c <= 300`

### Solution

```java
class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        if(mat.length*mat[0].length!=r*c) {
            return mat;
        }
        int[][] newMat = new int[r][c];
        int row = 0, col = 0;
        for(int i = 0; i < mat.length; i++) {
            for(int j = 0; j < mat[0].length; j++) {
                newMat[row][col++] = mat[i][j];
                if(col == c) {
                    col = 0;
                    row++;
                }
            }
        }
        return newMat;
    }
}
```



## [Medium] 36. Valid Sudoku

Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:

1. Each row must contain the digits `1-9` without repetition.
2. Each column must contain the digits `1-9` without repetition.
3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.

**Note:**

- A Sudoku board (partially filled) could be valid but is not necessarily solvable.
- Only the filled cells need to be validated according to the mentioned rules.

 

**Example 1:**

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

```
Input: board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: true
```

**Example 2:**

```
Input: board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
```

 

**Constraints:**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` is a digit `1-9` or `'.'`.

### Solution

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        boolean[][] v = new boolean[9][10];
        boolean[][] h = new boolean[9][10];
        boolean[][][] s = new boolean[3][3][10];
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] == '.') continue;
                int temp = board[i][j] - '0';
                if(h[i][temp]) return false;
                if(v[j][temp]) return false;
                if(s[i/3][j/3][temp]) return false;
                h[i][temp] = true;
                v[j][temp] = true;
                s[i/3][j/3][temp] = true;
            }
        }
        return true;
    }
}
```

## [Medium] 74. Search a 2D Matrix

Write an efficient algorithm that searches for a value in an `m x n` matrix. This matrix has the following properties:

- Integers in each row are sorted from left to right.
- The first integer of each row is greater than the last integer of the previous row.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
```

 

**Constraints:**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 100`
- `-104 <= matrix[i][j], target <= 104`

### Solution

从左下角或右上角遍历就完事儿了。

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int i = m - 1, j = 0;
        while(i >= 0 && j < n) {
            if(matrix[i][j] > target) {
                i--;
                continue;
            } else if (matrix[i][j] < target) {
                j++;
            } else {
                return true;
            }
        }
        return false;
    }
}
```



## [Hard] 668. Kth Smallest Number in Multiplication Table

Nearly everyone has used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication table of size `m x n` is an integer matrix `mat` where `mat[i][j] == i * j` (**1-indexed**).

Given three integers `m`, `n`, and `k`, return *the* `kth` *smallest element in the* `m x n` *multiplication table*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/multtable1-grid.jpg)

```
Input: m = 3, n = 3, k = 5
Output: 3
Explanation: The 5th smallest number is 3.
```

**Example 2:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/multtable2-grid.jpg)

```
Input: m = 2, n = 3, k = 6
Output: 6
Explanation: The 6th smallest number is 6.
```

 

**Constraints:**

- `1 <= m, n <= 3 * 104`
- `1 <= k <= m * n`

### Solution

这道题不讲码德o(≧口≦)o 没说有空间限制

正解用的二分搜索，数组做会Memory Limit Exceeded

```java
class Solution {
    public int findKthNumber(int m, int n, int k) {
        int low = 0, high = m*n;
        while(low<high) {
            int mid = low + (high - low) / 2;
            int count = 0;
            for(int i = 1; i <= m; i++) {
                count += n < mid/i ? n : mid/i;
            }
            if(count>=k) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
}
```

好像还能再贪心一下, 时间就100%了

```java
class Solution {
    public int findKthNumber(int m, int n, int k) {
        int low = 0, high = m*n;
        while(low<high) {
            int mid = low + (high - low) / 2;
            int count = 0, j = n;
            for(int i = 1; i <= m; i++) {
                while(i * j > mid) j--;
                count += j;
            }
            if(count>=k) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
}
```



## [Medium] 62. Unique Paths

A robot is located at the top-left corner of a `m x n` grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
Input: m = 3, n = 7
Output: 28
```

**Example 2:**

```
Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
```

**Example 3:**

```
Input: m = 7, n = 3
Output: 28
```

**Example 4:**

```
Input: m = 3, n = 3
Output: 6
```

 

**Constraints:**

- `1 <= m, n <= 100`
- It's guaranteed that the answer will be less than or equal to `2 * 109`.

### Solution

DFS超时，DP和数学方法可做.

第0行和第0列都赋初值1；对于其他位置的任意网格，只能从上边或者左边到达，而到达这一格子的路径个数就是它上边格子的值＋它左边格子的值。

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] map = new int[m][n];
        for(int i  = 0; i < m; i++) {
            map[i][0] = 1;
        }
        for(int i  = 0; i < n; i++) {
            map[0][i] = 1;
        }
        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j++) {
                map[i][j] = map[i-1][j] + map[i][j-1];
            }
        }
        return map[m-1][n-1];
    }
}
```

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int min = m > n ? n : m;
        int[] dp = new int[min];
        for(int i  = 0; i < min; i++) {
            dp[i] = 1;
        }
        for(int i = 1; i < ((m^n)^min); i++) {
            for(int j = 1; j < min; j++) {
                dp[j] = dp[j] + dp[j-1];
            }
        }
        
        return dp[min-1];
    }
    
}
```



## [Medium] 264. Ugly Number II

An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.

Given an integer `n`, return *the* `nth` ***ugly number***.

**Example 1:**

```
Input: n = 10
Output: 12
Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.
```

**Example 2:**

```
Input: n = 1
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
```

**Constraints:**

- `1 <= n <= 1690`

### Solution

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n + 1];
        dp[1] = 1;
        int p2 = 1, p3 = 1, p5 = 1;
        for(int i = 2; i <= n; i++) {
            int num2 = dp[p2]*2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;
            dp[i] = Math.min(Math.min(num2, num3), num5);
            if(dp[i] == num2) {
                p2++;
            }
            if(dp[i] == num3) {
                p3++;
            }
            if(dp[i] == num5) {
                p5++;
            }
        }
        return dp[n];
    }
}
```



## [Medium] 96. Unique Binary Search Trees

Given an integer `n`, return *the number of structurally unique **BST'**s (binary search trees) which has exactly* `n` *nodes of unique values from* `1` *to* `n`.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
Input: n = 3
Output: 5
```

**Example 2:**

```
Input: n = 1
Output: 1
```

**Constraints:**

- `1 <= n <= 19`

### Solution

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++) {
            for(int j = 1; j <= i; j++) {
                dp[i] += dp[j-1] * dp[i-j];
            }
        }
        return dp[n];
    }
}
```

## [Medium] 931. Minimum Falling Path Sum 

Given an `n x n` array of integers `matrix`, return *the **minimum sum** of any **falling path** through* `matrix`.

A **falling path** starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position `(row, col)` will be `(row + 1, col - 1)`, `(row + 1, col)`, or `(row + 1, col + 1)`.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg)

```
Input: matrix = [[2,1,3],[6,5,4],[7,8,9]]
Output: 13
Explanation: There are two falling paths with a minimum sum as shown.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg)

```
Input: matrix = [[-19,57],[-40,-5]]
Output: -59
Explanation: The falling path with a minimum sum is shown.
```

 

**Constraints:**

- `n == matrix.length == matrix[i].length`
- `1 <= n <= 100`
- `-100 <= matrix[i][j] <= 100`

### Solution

自顶向下，暴力，memo消除重复子问题

```java
class Solution {
    private static int[][] memo; // 备忘录
    public int minFallingPathSum(int[][] matrix) {
        int res = Integer.MAX_VALUE; 
        memo = new int[matrix.length][matrix.length];
        for(int i = 0; i < matrix.length; i++) {
            Arrays.fill(memo[i],10001); // 可取值 (-inf, -10001] U [10001, +inf) 
        }
        // 终点可能在最后一行的任意一列
        for(int i = 0; i < matrix.length; i++) {
            res = Math.min(res, dp(matrix, matrix.length - 1, i));
        }
        return res;
    }
    //从第一行（matrix[0][..]）向下落，落到位置 matrix[i][j] 的最小路径和为 dp(matrix, i, j)
    private static int dp(int[][] matrix, int i, int j) {
        //边界条件
        if(i < 0 || j < 0 || i >= matrix.length || j >= matrix.length) {
            return 10001;
        }
        if(i == 0) return matrix[0][j];
        // 消除重复计算
        if(memo[i][j]!=10001) return memo[i][j];
        // 状态转移
        memo[i][j] = matrix[i][j] + Math.min(Math.min(dp(matrix, i - 1, j), dp(matrix, i - 1, j - 1)), dp(matrix, i - 1, j + 1));
        return memo[i][j];
    }
}
```



## [Medium] 106. Construct Binary Tree from Inorder and Postorder Traversal

Given two integer arrays `inorder` and `postorder` where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return *the binary tree*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
```

**Example 2:**

```
Input: inorder = [-1], postorder = [-1]
Output: [-1]
```

 

**Constraints:**

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` and `postorder` consist of **unique** values.
- Each value of `postorder` also appears in `inorder`.
- `inorder` is **guaranteed** to be the inorder traversal of the tree.
- `postorder` is **guaranteed** to be the postorder traversal of the tree.

### Solution

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/202111211617876.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        return buildSubTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }
    private TreeNode buildSubTree(int[] inorder, int start1, int end1, int[] postorder, int start2, int end2) {
        if(end1-start1<0) {
            return null;
        }
        if(end1==start1) {
            return new TreeNode(inorder[end1]);
        }
        TreeNode root = new TreeNode(postorder[end2]);
        int rootInorderIndex = 0;
        for(int i = start1; i <= end1; i++) {
            if(inorder[i]==postorder[end2]) {
                rootInorderIndex = i;
                break;
            }
        }
        root.left = buildSubTree(inorder, start1, rootInorderIndex - 1, postorder, start2, start2 + rootInorderIndex - start1 - 1);
        root.right = buildSubTree(inorder, rootInorderIndex + 1, end1, postorder, start2 + rootInorderIndex - start1, end2 - 1);
        return root;
    }
}
```

## [Medium] 450. Delete Node in a BST

Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

1. Search for a node to remove.
2. If the node is found, delete the node.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

```
Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.
```

**Example 2:**

```
Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.
```

**Example 3:**

```
Input: root = [], key = 0
Output: []
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[0, 104]`.
- `-105 <= Node.val <= 105`
- Each node has a **unique** value.
- `root` is a valid binary search tree.
- `-105 <= key <= 105`

### Solution

- 如果 `key > root.val`，说明要删除的节点在右子树，`root.right = deleteNode(root.right, key)`。
- 如果 `key < root.val`，说明要删除的节点在左子树，`root.left = deleteNode(root.left, key)`。
- 如果`key == root.val`则该节点就是我们要删除的节点，则：
  - 如果该节点是叶子节点，则直接删除它：`root = null`。
  - 如果该节点不是叶子节点且有右节点，则用它的后继节点的值替代 `root.val = successor.val`，然后删除后继节点。
  - 如果该节点不是叶子节点且只有左节点，则用它的前驱节点的值替代 `root.val = predecessor.val`，然后删除前驱节点。
- 返回 `root`。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root == null) return null;
        if(key > root.val) root.right = deleteNode(root.right, key);
        else if (key < root.val) root.left = deleteNode(root.left, key);
        else {
            if (root.left == null && root.right == null) root = null;
            else if (root.right != null) {
                root.val = successor(root);
                root.right = deleteNode(root.right, root.val);
            } else {
                root.val = predecessor(root);
                root.left = deleteNode(root.left, root.val);
            }
        }
        return root;
    }
    public int successor(TreeNode root) {
        root = root.right;
        while (root.left != null) root = root.left;
        return root.val;
  }

    public int predecessor(TreeNode root) {
        root = root.left;
        while (root.right != null) root = root.right;
        return root.val;
    }

}
```


## [Medium] 238. Product of Array Except Self

Given an integer array `nums`, return *an array* `answer` *such that* `answer[i]` *is equal to the product of all the elements of* `nums` *except* `nums[i]`.

The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

You must write an algorithm that runs in `O(n)` time and without using the division operation.

 

**Example 1:**

```
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
```

**Example 2:**

```
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
```

 

**Constraints:**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.

 

**Follow up:** Can you solve the problem in `O(1) `extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)



### Solution

一次遍历记住当前位置左边数的乘积，再用一次循环乘以它右边数的乘积

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] res = new int[nums.length];
        res[0] = 1;
        for(int i = 1; i < nums.length; i++) {
            res[i] = res[i-1] * nums[i-1];
        }
        int temp = 1;
        for(int i = nums.length - 1; i >= 0; i--) {
            res[i] *= temp;
            temp *= nums[i];            
        }
        return res;
    }
}
```
## [Hard] 85. Maximal Rectangle

Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return *its area*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/maximal.jpg)

```
Input: matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
Output: 6
Explanation: The maximal rectangle is shown in the above picture.
```

**Example 2:**

```
Input: matrix = []
Output: 0
```

**Example 3:**

```
Input: matrix = [["0"]]
Output: 0
```

**Example 4:**

```
Input: matrix = [["1"]]
Output: 1
```

**Example 5:**

```
Input: matrix = [["0","0"]]
Output: 0
```

 

**Constraints:**

- `rows == matrix.length`
- `cols == matrix[i].length`
- `0 <= row, cols <= 200`
- `matrix[i][j]` is `'0'` or `'1'`.



### Solution

有点儿难，得先做84题

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int m = matrix.length;
        if (m == 0) return 0;
        int n = matrix[0].length;
        int[][] left = new int[m][n];
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;
                }
            }
        }
        
        int ans = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '0') {
                    continue;
                }
                int width = left[i][j];
                int area = width;
                for (int k = i - 1; k >= 0; k--) {
                    if (width == 0) break;
                    width = Math.min(width, left[k][j]);
                    area = Math.max(area, (i - k + 1) * width);
                }
                ans = Math.max(ans, area);
            }
        }
        return ans;
    }
}
```



## [Medium] 797. All Paths From Source to Target

Given a directed acyclic graph (**DAG**) of `n` nodes labeled from `0` to `n - 1`, find all possible paths from node `0` to node `n - 1` and return them in **any order**.

The graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`).

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/all_1.jpg)

```
Input: graph = [[1,2],[3],[3],[]]
Output: [[0,1,3],[0,2,3]]
Explanation: There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)

```
Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]
Output: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
```

**Example 3:**

```
Input: graph = [[1],[]]
Output: [[0,1]]
```

**Example 4:**

```
Input: graph = [[1,2,3],[2],[3],[]]
Output: [[0,1,2,3],[0,2,3],[0,3]]
```

**Example 5:**

```
Input: graph = [[1,3],[2],[3],[]]
Output: [[0,1,2,3],[0,3]]
```

 

**Constraints:**

- `n == graph.length`
- `2 <= n <= 15`
- `0 <= graph[i][j] < n`
- `graph[i][j] != i` (i.e., there will be no self-loops).
- All the elements of `graph[i]` are **unique**.
- The input graph is **guaranteed** to be a **DAG**.



### Solution

回溯！

```java
class Solution {
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfsBacktracking(graph, 0, res, path);
        return res;
    }
    private void dfsBacktracking (int[][] graph, int node, List<List<Integer>> res, List<Integer> path) {
        if (node == graph.length - 1) {
            res.add(new ArrayList<Integer>(path));
            return;
        }
        for (int nextNode : graph[node]) {
            path.add(nextNode);
            dfsBacktracking(graph, nextNode, res, path);
            path.remove(path.size() - 1);
        }
    }
}
```

## [Medium] 198. House Robber
[Goto](https://abnerhung.github.io/_posts/2021-11-03-LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/#medium-198-house-robber)


## [Easy] 1005. Maximize Sum Of Array After K Negations

Given an integer array `nums` and an integer `k`, modify the array in the following way:

- choose an index `i` and replace `nums[i]` with `-nums[i]`.

You should apply this process exactly `k` times. You may choose the same index `i` multiple times.

Return *the largest possible sum of the array after modifying it in this way*.

 

**Example 1:**

```
Input: nums = [4,2,3], k = 1
Output: 5
Explanation: Choose index 1 and nums becomes [4,-2,3].
```

**Example 2:**

```
Input: nums = [3,-1,0,2], k = 3
Output: 6
Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].
```

**Example 3:**

```
Input: nums = [2,-3,-1,5,-4], k = 2
Output: 13
Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].
```

 

**Constraints:**

- `1 <= nums.length <= 104`
- `-100 <= nums[i] <= 100`
- `1 <= k <= 104`

### Solution

不是很easy的easy

排序，把前k个以内的数翻转，sum记录总和，每次翻转k--，遍历完一遍数组，找到全局绝对值最小的数，如果剩下的k是奇数，真实答案比sum少了2倍的全局绝对值最小数。

```java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        Arrays.sort(nums);
        int sum = 0, m = 111;
        for(int i : nums) {
            if(k > 0 && -i > 0) {
                sum += -i;
                k--;
            } else {
                sum += i;
            }
            m = m < Math.abs(i) ? m : Math.abs(i);
        }
        return (k & 1) > 0 ? sum - m - m : sum;
    }
}
```

时间更优解

```java

class Solution {
     public int largestSumAfterKNegations(int[] A, int K) {
        int[] number = new int[201];//-100 <= A[i] <= 100,这个范围的大小是201
        for (int t : A) {
            number[t + 100]++;//将[-100,100]映射到[0,200]上
        }
        int i = 0;
        while (K > 0) {
            while (number[i] == 0)//找到A[]中最小的数字
                i++;
            number[i]--;//此数字个数-1
            number[200 - i]++;//其相反数个数+1
            if (i > 100) {//若原最小数索引>100,则新的最小数索引应为200-i.(索引即number[]数组的下标)
                i = 200 - i;
            }
            K--;
        }
        int sum = 0;
        for (int j = i; j <number.length ; j++) {//遍历number[]求和
            sum += (j-100)*number[j];//j-100是数字大小,number[j]是该数字出现次数.
        }
        return sum;
    }
}
```

## [Easy] 1217. Minimum Cost to Move Chips to The Same Position

We have n chips, where the position of the ith chip is position[i].

We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:

position[i] + 2 or position[i] - 2 with cost = 0.
position[i] + 1 or position[i] - 1 with cost = 1.
Return the minimum cost needed to move all the chips to the same position.

 

Example 1:


Input: position = [1,2,3]
Output: 1
Explanation: First step: Move the chip at position 3 to position 1 with cost = 0.
Second step: Move the chip at position 2 to position 1 with cost = 1.
Total cost is 1.
Example 2:


Input: position = [2,2,2,3,3]
Output: 2
Explanation: We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.
Example 3:

Input: position = [1,1000000000]
Output: 1
 

Constraints:

1 <= position.length <= 100
1 <= position[i] <= 10^9

### Solution
```java
class Solution {
    public int minCostToMoveChips(int[] position) {
        int a = 0, b = 0;
        for(int i : position) {
            if(i % 2 == 0) {
                a++;
            } else {
                b++;
            }
        }
        return a < b ? a : b;
    }
}

```


## [Easy] 938. Range Sum of BST

Given the `root` node of a binary search tree and two integers `low` and `high`, return *the sum of values of all nodes with a value in the **inclusive** range* `[low, high]`.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg)

```
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
Output: 32
Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg)

```
Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
Output: 23
Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 2 * 104]`.
- `1 <= Node.val <= 105`
- `1 <= low <= high <= 105`
- All `Node.val` are **unique**.

### Solution

递归1

```java
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null) {
            return 0;
        }
        int sum = 0;
        if(root.val < low) {
            sum += rangeSumBST(root.right, low, high); 
            return sum;
        } else if(root.val <= high) {
            sum += rangeSumBST(root.right, low, high);  
            sum += rangeSumBST(root.left, low, high);  
            return sum + root.val;
        } else {
            sum += rangeSumBST(root.left, low, high);  
            return sum;
        }
        
    }
}
```

简化版本递归

```java
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        if(root == null) {
            return 0;
        }
        if(root.val < low) {
            return rangeSumBST(root.right, low, high); 
        } else if(root.val <= high) {
            return root.val + rangeSumBST(root.right, low, high) + rangeSumBST(root.left, low, high);
        } else {
            return rangeSumBST(root.left, low, high);  
        }
    }
}
```
















































# tricks

## 多数问题：摩尔投票法

 Boyer-Moore Voting Algorithm, 又称为多数投票法，摩尔投票法的一大应用就是**求众数**。

  摩尔投票法基于这样一个事实，**当一个数的重复次数超过数组长度的一半，每次将两个不相同的数删除，最终剩下的就是要找的数。**

摩尔投票法分为两个阶段：**抵消阶段和计数阶段**。

  **抵消阶段**：两个不同投票进行对坑，并且同时抵消掉各一张票，如果两个投票相同，则累加可抵消的次数；

  **计数阶段**：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定。

==算法步骤==：

1. `count = 0；` ` num = nums[0];` 表示从此时开始计算投票。

2. 遍历数组，如果接下来出现的数字与`num`相同，`count`加1。如果不同，`count`减1。

3. 如果`count == 0`，表示之前出现的所有数字中`num`都是可以凑成不同的数对，一起抵消。大于`1/2 n`的数还会在后面出现。

4. 如果`count < 0`，表示之前`num`中的数字没有到一半，所以此时完全不用考虑前面存储的元素，“删除”他们。直接从现在的新的元素开始计数，并令`count = 0`。

对于出现超过`n/2`次数的元素：

```java
class Solution {
    public int majorityElement(int[] nums) {
        int vote = 0, element = 0;
        for(int num : nums) {
            if(vote > 0 && num == element) {
                vote++;
            } else if(vote==0) {
                vote++;
                element = num;
            } else {
                vote--;
            }
        }
        return element;
    }
}
```

对于出现超过`n/3`次数的元素：

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> ans;
        int vote1 = 0, vote2 = 0, element1 = 0, element2 = 0;
        for(int num : nums) {
            if(vote1 > 0 && num == element1){
                vote1++;
            } else if(vote2 > 0 && num == element2) {
                vote2++;
            } else if(vote1 == 0) {
                vote1++;
                element1 = num;
            } else if (vote2==0) {
                vote2++;
                element2 = num;
            } else {
                vote2--;
                vote1--;
            }
        }

        int count1 = 0, count2 = 0;
        for(int num : nums) {
            if(vote1 > 0 && num == element1) {
                count1++;
            }
            if(vote2 > 0 && num == element2) {
                count2++;
            }
        }

        ans = new ArrayList<>();
        if(vote1 > 0 && count1 > nums.length / 3){
            ans.add(element1);
        }
        if(vote2 > 0 && count2 > nums.length / 3){
            ans.add(element2);
        }
        
        return ans;
    }
}
```

可以扩展至找出出现次数超过`1/k`次的元素的问题：

**至多选出m个代表，每个选票数大于n / (m + 1)**







## 折半查找/二分搜索

对于有序的数组，优先考虑这个

## 单调栈



## DFS







## 异或

### 性质：

**[交换律](https://zh.wikipedia.org/wiki/交换律)**：![{\displaystyle p\oplus q=q\oplus p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/110615f4e2eac3794ceff1a3ce124c514edcbe21)

**[结合律](https://zh.wikipedia.org/wiki/结合律)**：![{\displaystyle p\oplus (q\oplus r)=(p\oplus q)\oplus r}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2bd7e13889de806aef9c852cf7d4679aa869c66d)

**恒等律**：![{\displaystyle p\oplus 0=p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2b51c3409f9ec2458c703a0e197a0f8be35107f6)

**归零律**：![{\displaystyle p\oplus p=0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b344ce1ebeb618481da59f2894dea398cf1503aa)

**[自反](https://zh.wikipedia.org/wiki/自反关系)**： ![{\displaystyle p\oplus q\oplus q=p\oplus 0=p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/62d8e0ecddcbe17c8b1fd9dbf00aff0c3083ee4e)

### 用法

根据自反或者归零的性质，异或常用于找缺失数、找出现一次数、找出现奇数次数之类的应用。还可用于不引入临时变量的交换。

#### 例：

Swap:

```java
private void swap(int[] nums, int i, int j){
    if(i!=j) {//同一地址异或会归零，交换时应避免出现相同地址的元素交换。
    	nums[i]=nums[i]^nums[j];
        nums[j]=nums[i]^nums[j];
        nums[i]=nums[i]^nums[j];
    }
}
```

Single Number(在同一数字最多出现两次的数组中，找到只出现过一次的数字):

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for(int num:nums) ans^=num;
        return ans;
    }
}
```

Single Number的进阶版，[260题](#260)

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        /*if(nums.length==2){
            return nums;
        }*/
        int temp=0;
        for(int n:nums){
            temp^=n;
        }
        int temp2=(~temp+1)&temp;//得到最右边的1
        int temp3=temp;
        for(int n:nums){
            if((n&temp2)>0){//那一位是1的
                temp3^=n;
            }
        }
        return new int[]{temp3,temp3^temp};
    }
}
```



## DP

