---
redirect_from: /_posts/2021-11-03-LeetCode每日一题.md/
title: LeetCode每日一题
tags:
  - Java
  - DataStructure
---

# 每日一题

## [Easy] 453. Minimum Moves to Equal Array Elements

Given an integer array `nums` of size `n`, return *the minimum number of moves required to make all array elements equal*.

In one move, you can increment `n - 1` elements of the array by `1`.

 

**Example 1:**

```
Input: nums = [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements):
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```

**Example 2:**

```
Input: nums = [1,1,1]
Output: 0
```

 

**Constraints:**

- `n == nums.length`
- `1 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- The answer is guaranteed to fit in a **32-bit** integer.

### My solution

n-1个元素增加一，相当于剩下的一个元素减小1。只需找到最小的元素，移动次数即为最小元素与各个元素的差的和；

```java
class Solution {
    public int minMoves(int[] nums) {
        // Arrays.sort(nums);
        // int minnum = nums[0];
        int minnum = Arrays.stream(nums).min().getAsInt();
        int res=0;
        for(int i=0;i<nums.length;i++){
            res+=nums[i]-minnum;
        }
        return res;
    }
}
```

优化后：

```java
class Solution {
    public int minMoves(int[] nums) {
        int minnum = nums[0];
        int sum=minnum;
        for(int i=1;i<nums.length;i++){
            if(nums[i]<minnum){
                minnum = nums[i];
            }
            sum+=nums[i];
        }
        return sum-minnum*nums.length;
    }
}
```





## [Medium] 151. Reverse Words in a String

Given an input string `s`, reverse the order of the **words**.

A **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.

Return *a string of the words in reverse order concatenated by a single space.*

**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

 

**Example 1:**

```
Input: s = "the sky is blue"
Output: "blue is sky the"
```

**Example 2:**

```
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
```

**Example 3:**

```
Input: s = "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
```

**Example 4:**

```
Input: s = "  Bob    Loves  Alice   "
Output: "Alice Loves Bob"
```

**Example 5:**

```
Input: s = "Alice does not even like bob"
Output: "bob like even not does Alice"
```

 

**Constraints:**

- `1 <= s.length <= 104`
- `s` contains English letters (upper-case and lower-case), digits, and spaces `' '`.
- There is **at least one** word in `s`.

 

**Follow-up:** If the string data type is mutable in your language, can you solve it **in-place** with `O(1)` extra space?



### Solution

使用库函数

```java
class Solution {
    public String reverseWords(String s) {
        String[] res = s.trim().split(" +");
        Collections.reverse(Arrays.asList(res));
        return String.join(" ", res);
    }
}
```

O(1) extra space 解法

- 去除多余的空格

- 把每一个单词逆置
- 再把整个字符串翻转

```java
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = removeSpace(s);
        reverseEverything(sb,0,sb.length()-1);
        reverseEachWord(sb);
        return sb.toString();
    }
    
    private StringBuilder removeSpace(String s) {
        int start = 0, end = s.length()-1;
        while(s.charAt(start)==' ') {
            start++;
        }
        while(s.charAt(end)==' ') {
            end--;
        }
        StringBuilder sb = new StringBuilder();
        while(start<=end) {
            char c = s.charAt(start);
            if(c != ' '||sb.charAt(sb.length()-1) != ' ') {
                sb.append(c);
            }
            start++;
        }
        return sb;
    }
    
    private void reverseEverything(StringBuilder sb, int start, int end) {
        while(start<end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
        }
        
    }
    
    private void reverseEachWord(StringBuilder sb) {
        int start = 0, end = 1;
        while(start < sb.length()) {
            while((end<sb.length())&&(sb.charAt(end)!=' ')) {
                end++;
            }
            reverseEverything(sb,start,end-1);
            start = end+1;
            end = start+1;
        }
    }
}
```



## [Easy] 66. Plus One

You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.

Increment the large integer by one and return *the resulting array of digits*.

 

**Example 1:**

```
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].
```

**Example 2:**

```
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].
```

**Example 3:**

```
Input: digits = [0]
Output: [1]
Explanation: The array represents the integer 0.
Incrementing by one gives 0 + 1 = 1.
Thus, the result should be [1].
```

**Example 4:**

```
Input: digits = [9]
Output: [1,0]
Explanation: The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].
```

 

**Constraints:**

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`
- `digits` does not contain any leading `0`'s.

### My Solution

直接模拟

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int temp=1;
        for(int i = digits.length-1;i>=0;i--) {
            digits[i]+=temp;
            if(digits[i]>=10) {
                temp=digits[i]/10;
                digits[i]-=10*temp;
            } else{
                temp = 0;
            }
        }
        if(digits[0]==0&&temp>=1) {
            int[] res  = new int[digits.length+1];
            res[0]=1;
           return res;
            
        }
        return digits;
    }
}
```

找最长后缀9，第一个不为9的数+1，将末尾9置零：

```java
class Solution {
    public int[] plusOne(int[] digits) {
        for(int i = digits.length-1;i>=0;i--) {
            if(digits[i]!=9) {
                ++digits[i];
                for(int j=i+1;j<digits.length;j++) {
                    digits[j]=0;
                }
                return digits;
            } 
        }
        int[] res = new int [digits.length+1];
        res[0]=1;
        return res;        
    }
}
```



## [Medium] 380. Insert Delete GetRandom O(1)

Implement the `RandomizedSet` class:

- `RandomizedSet()` Initializes the `RandomizedSet` object.
- `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.
- `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.
- `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.

You must implement the functions of the class such that each function works in **average** `O(1)` time complexity.

 

**Example 1:**

```
Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
```

 

**Constraints:**

- `-2^31 <= val <= 2^31 - 1`
- At most `2 * 10^5` calls will be made to `insert`, `remove`, and `getRandom`.
- There will be **at least one** element in the data structure when `getRandom` is called.



### Solution

重点:  插入时记录每个元素的位置，remove时用最后的element去替换要删除的元素，删除dict中的键值对，删除list的最后一个元素。

```java
class RandomizedSet {
    
    Map<Integer, Integer> dict= new HashMap();
    List<Integer> list = new ArrayList();
    Random rand = new Random();

    public RandomizedSet() {
    }
    
    public boolean insert(int val) {
        if(dict.containsKey(val)){
            return false;
        }
        dict.put(val,list.size());
        list.add(list.size(),val);
        return true;
    }
    
    public boolean remove(int val) {
        if(!dict.containsKey(val)){
            return false;
        }
        int lastElement = list.get(list.size()-1);
        int id = dict.get(val);
        list.set(id,lastElement);
        dict.put(lastElement,id);
        list.remove(list.size()-1);
        dict.remove(val);
        return true;
    }
    
    public int getRandom() {
        return list.get(rand.nextInt(list.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```



## [Medium] 229. Majority Element II

Given an integer array of size `n`, find all elements that appear more than `⌊ n/3 ⌋` times.

 

**Example 1:**

```
Input: nums = [3,2,3]
Output: [3]
```

**Example 2:**

```
Input: nums = [1]
Output: [1]
```

**Example 3:**

```
Input: nums = [1,2]
Output: [1,2]
```

 

**Constraints:**

- `1 <= nums.length <= 5 * 104`
- `-109 <= nums[i] <= 109`

 

**Follow up:** Could you solve the problem in linear time and in `O(1)` space?



### Solution

 Boyer-Moore Voting Algorithm

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> ans;
        int vote1=0,vote2=0,element1=0,element2=0;
        for(int num:nums) {
            if(vote1>0&&num==element1){
                vote1++;
            } else if(vote2>0&&num==element2) {
                vote2++;
            } else if(vote1==0){
                vote1++;
                element1 = num;
            } else if (vote2==0) {
                vote2++;
                element2 = num;
            } else {
                vote2--;
                vote1--;
            }
        }

        int count1 = 0, count2 = 0;
        for(int num:nums) {
            if(vote1>0&&num==element1) {
                count1++;
            }
            if(vote2>0&&num==element2) {
                count2++;
            }
        }

        ans = new ArrayList<>();
        if(vote1>0&&count1>nums.length/3){
            ans.add(element1);
        }
        if(vote2>0&&count2>nums.length/3){
            ans.add(element2);
        }
        
        return ans;
    }
}
```



## [Medium] 451. Sort Characters By Frequency

Given a string `s`, sort it in **decreasing order** based on the **frequency** of the characters. The **frequency** of a character is the number of times it appears in the string.

Return *the sorted string*. If there are multiple answers, return *any of them*.

 

**Example 1:**

```
Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
```

**Example 2:**

```
Input: s = "cccaaa"
Output: "aaaccc"
Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
Note that "cacaca" is incorrect, as the same characters must be together.
```

**Example 3:**

```
Input: s = "Aabb"
Output: "bbAa"
Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
```

 

**Constraints:**

- `1 <= s.length <= 5 * 105`
- `s` consists of uppercase and lowercase English letters and digits.



### Solution

```java
class Solution {
public:
    static bool cmp(pair<char, int> p1, pair<char, int> p2){
	    return p1.second > p2.second;
    }
    string frequencySort(string s) {
        map<char,int> m;
        string res;
        for(int i = 0;i < s.size();i++){
            m[s[i]]++;
        }
        vector<pair<char,int>> v;
        for(auto x: m)
        {
            v.push_back({x.first,x.second});
        }
        sort(v.begin(), v.end(), cmp);
        for(auto itr = v.begin(); itr != v.end(); ++itr) {
            for(int k=0;k<itr->second;k++) {
                res+=(itr->first);
            }            
	    }
        return res;
    }

};
```



## [Easy] 492. Construct the Rectangle

A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:

1. The area of the rectangular web page you designed must equal to the given target area.
2. The width `W` should not be larger than the length `L`, which means `L >= W`.
3. The difference between length `L` and width `W` should be as small as possible.

Return *an array `[L, W]` where `L` and `W` are the length and width of the web page you designed in sequence.*

 

**Example 1:**

```
Input: area = 4
Output: [2,2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
```

**Example 2:**

```
Input: area = 37
Output: [37,1]
```

**Example 3:**

```
Input: area = 122122
Output: [427,286]
```

 

**Constraints:**

- `1 <= area <= 107`

### Solution

area除以它一个数，直到能整除，输出商和这个数；这数从area的平方根开始递减，最坏情况降到1；

```java
class Solution {
    public int[] constructRectangle(int area) {
        for(int i = (int)(Math.sqrt(area)); ;i--) {
            if(area%i==0) return new int[]{area/i,i};
        }
    }
}
```



## [Hard] 154. Find Minimum in Rotated Sorted Array II

Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:

- `[4,5,6,7,0,1,4]` if it was rotated `4` times.
- `[0,1,4,4,5,6,7]` if it was rotated `7` times.

Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` that may contain **duplicates**, return *the minimum element of this array*.

You must decrease the overall operation steps as much as possible.

 

**Example 1:**

```
Input: nums = [1,3,5]
Output: 1
```

**Example 2:**

```
Input: nums = [2,2,2,0,1]
Output: 0
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` is sorted and rotated between `1` and `n` times.

 

**Follow up:** This problem is similar to [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/), but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?



### Solution

Bin Search

```java
class Solution {
    public int findMin(int[] nums) {
        int lo = 0,hi=nums.length-1;
        if (nums[lo] < nums[hi]) return nums[lo];
        while(lo<hi) {
            int mid = lo + (hi - lo) / 2;
            if(nums[mid]<nums[hi]){
                hi = mid;
            }else if(nums[mid]>nums[hi]){
                lo = mid+1;
            } else{
                 hi--;
            }
        } 
        return nums[hi];
    }

}
```





## [Easy]496. Next Greater Element I

The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.

You are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.

For each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.

Return *an array* `ans` *of length* `nums1.length` *such that* `ans[i]` *is the **next greater element** as described above.*

 

**Example 1:**

```
Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
```

**Example 2:**

```
Input: nums1 = [2,4], nums2 = [1,2,3,4]
Output: [3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.
```

 

**Constraints:**

- `1 <= nums1.length <= nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 104`
- All integers in `nums1` and `nums2` are **unique**.
- All the integers of `nums1` also appear in `nums2`.

### Solution

单调栈经典例题

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer,Integer> res = nextGreater(nums2);
        int[] resores = new int[nums1.length];
        for(int i =0;i<nums1.length;i++){
            resores[i] = res.getOrDefault(nums1[i], -1);;
        }
        return resores;
    }

    private Map<Integer,Integer> nextGreater(int[] arr){
        Stack<Integer> stack = new Stack<>();
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0;i<arr.length;i++){
            while(!stack.isEmpty() &&stack.peek() <arr[i]){
                 map.put(stack.pop(), arr[i]);
            }
            stack.push(arr[i]);
        }
        return map;
    }
}
```



## [Easy] 226. Invert Binary Tree

Given the `root` of a binary tree, invert the tree, and return *its root*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/invert1-tree.jpg)

```
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
Input: root = [2,1,3]
Output: [2,3,1]
```

**Example 3:**

```
Input: root = []
Output: []
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[0, 100]`.
- `-100 <= Node.val <= 100`



### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode  new_root = root;
        if(root.left!=null||root.right!=null) {
            TreeNode  temp = root.left;
            root.left = root.right;
            root.right = temp;
            root.left = invertTree(root.left);
            root.right = invertTree(root.right);
        }
        return new_root;
    }
}
```



## [Medium] 75. Sort Colors

Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

 

**Example 1:**

```
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

**Example 2:**

```
Input: nums = [2,0,1]
Output: [0,1,2]
```

**Example 3:**

```
Input: nums = [0]
Output: [0]
```

**Example 4:**

```
Input: nums = [1]
Output: [1]
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` is `0`, `1`, or `2`.



### Solution

用的快排，时间$O(nlogn)$, 空间$O(logn)$

```java
class Solution {
    public void sortColors(int[] nums) {
        quickSort(nums,0,nums.length-1);
    }
    private int[] quickSort(int[] num,int left, int right){
        if(left<right){
            int partitionIndex = partition(num,left,right);
            quickSort(num,left,partitionIndex-1);
            quickSort(num,partitionIndex+1,right);
        }
        return num;
    }
    private int partition(int arr[],int left ,int right) {
        int j = left+1;
        for(int k = j;k<=right;k++){
            if(arr[k]<arr[left]){
                swap(arr,k,j);
                j++;
            }
        }
        swap(arr,left,j-1);
        return j-1;
    }
    private int[] swap(int[] arr,int left,int right){
        if(left!=right){
            arr[left] = arr[left]^arr[right];
            arr[right] = arr[left]^arr[right];
            arr[left] = arr[left]^arr[right];
        }
        return arr;
    }
}
```

**Follow up:** Could you come up with a one-pass algorithm using only constant extra space?

我的快排空间复杂度不满足QAQ，针对这道题改一下：

```java
class Solution {
    public void sortColors(int[] nums) {
        if(nums.length<2) return;
        int zero = 0;
        int two = nums.length;
        int i = 0;
        while(i<two){
            if(nums[i]==0){
                swap(nums,zero,i);
                zero++;
                i++;
            } else if(nums[i]==1){
                i++;
            } else{
                two--;
                swap(nums,two,i);
            }
        }
        
        
    }
    private int[] swap(int[] arr,int left,int right){
        if(left!=right){
            arr[left] = arr[left]^arr[right];
            arr[right] = arr[left]^arr[right];
            arr[left] = arr[left]^arr[right];
        }
        return arr;
    }
}
```



## [Hard] 301. Remove Invalid Parentheses

Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return *all the possible results*. You may return the answer in **any order**.

 

**Example 1:**

```
Input: s = "()())()"
Output: ["(())()","()()()"]
```

**Example 2:**

```
Input: s = "(a)())()"
Output: ["(a())()","(a)()()"]
```

**Example 3:**

```
Input: s = ")("
Output: [""]
```

 

**Constraints:**

- `1 <= s.length <= 25`
- `s` consists of lowercase English letters and parentheses `'('` and `')'`.
- There will be at most `20` parentheses in `s`.



### Solution

广度优先搜索

注意到题目中要求最少删除，这样的描述正是广度优先搜索算法应用的场景，并且题目也要求我们输出所有的结果。我们在进行广度优先搜索时每一轮删除字符串中的 11 个括号，直到出现合法匹配的字符串为止，此时进行轮转的次数即为最少需要删除括号的个数。

我们进行广度优先搜索时，每次保存上一轮搜索的结果，然后对上一轮已经保存的结果中的每一个字符串尝试所有可能的删除一个括号的方法，然后将保存的结果进行下一轮搜索。在保存结果时，我们可以利用哈希表对上一轮生成的结果去重，从而提高效率。`

```java
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        List<String> ans = new ArrayList<String>();
        Set<String> currentSet =  new HashSet<String>();
        currentSet.add(s);
        while(true){
            for(String str:currentSet) {
                if(isVaild(str)){
                    ans.add(str);
                }
            }
            if(ans.size()>0){
                return ans;
            }
            Set<String> nextSet =  new HashSet<String>();
            for(String str:currentSet){
                for(int i=0;i<str.length();i++){
                    if(i>0&&str.charAt(i)==str.charAt(i-1)){
                        continue;
                    }
                    if(str.charAt(i)=='('||str.charAt(i)==')') {
                        nextSet.add(str.substring(0,i)+str.substring(i+1));
                    }
                }
            }
            currentSet = nextSet;
        }
    }

    private boolean isVaild(String str ){
        char[] ss = str.toCharArray();
        int count = 0;
        for(char s:ss){
            if(s=='('){
                count++;
            } else if(s==')'){
                count--;
                if(count<0){
                    return false;
                }
            }
        }
        return count == 0;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n \times 2^n)$，其中 $n$ 为字符串的长度。考虑到一个字符串最多可能有 $2^n$ 个子序列，因此时间复杂度为 $O(n \times 2^n)$。
- 空间复杂度：$O(n \times C_n^\frac{n}{2})$，其中 $n$为字符串的长度。我们在进行第 $i$ 轮迭代时，会从原始字符串中删除 $i$个括号，因此第 $i$轮迭代产生的字符串最多有 $C_n^i $个，当$ i = \frac{n}{2}$时组合数最大，此时迭代生成的字符串个数最多，因此空间复杂度为$ O(n \times C_n^\frac{n}{2})$。

## [Medium] 15. 3Sum

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

 

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Example 2:**

```
Input: nums = []
Output: []
```

**Example 3:**

```
Input: nums = [0]
Output: []
```

 

**Constraints:**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`



### Solution

排序后固定一个指针移动两个指针，找到和为0的加到List里面

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i = 0;i<nums.length-2;i++){//i<j<k故i最大也小于length-2
            if(nums[i]>0) break;//因为已排好序，若i对应元素已经大于零了，就没必要继续匹配了
            if(i>0&&nums[i]==nums[i-1]) continue;
            int j=i+1,k=nums.length-1;//j从i的后面开始移动，k从末尾往前移动
            while(j<k){
                int sum = nums[i]+nums[j]+nums[k];
                if(sum<0){
                    while(j<k&&nums[j]==nums[++j]);//若相同继续移动
                } else if (sum>0){
                    while(j<k&&nums[k]==nums[--k]);//k从后往前移
                } else{
                    res.add(new ArrayList(Arrays.asList(nums[i],nums[j],nums[k])));
                    while(j<k&&nums[j]==nums[++j]);//j继续后移
                    while(j<k&&nums[k]==nums[--k]);//k继续前移
                }
            }
        }
        return res;
    }
}
```



## [Medium] 869. Reordered Power of 2

You are given an integer `n`. We reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return `true` *if and only if we can do this so that the resulting number is a power of two*.

 

**Example 1:**

```
Input: n = 1
Output: true
```

**Example 2:**

```
Input: n = 10
Output: false
```

**Example 3:**

```
Input: n = 16
Output: true
```

**Example 4:**

```
Input: n = 24
Output: false
```

**Example 5:**

```
Input: n = 46
Output: true
```

 

**Constraints:**

- `1 <= n <= 109`



### Solution

打表＋词频统计

由于$ 2^{29} < 10^9 < 2^{30}$，因此在$ [1,10^9]$范围内有 $2^0,2^1,\cdots,2^{29}$ 一共$30$ 个$ 2$ 的幂。对这 $30$个数的每个数，我们可以预处理其十进制表示的字符数组中从 $\texttt{0} $到$ \texttt{9}$ 每个字符的出现次数，记在一个长度为$10$ 的数组中，并用一哈希表记录这些数组。对于数字 $n$，我们同样统计其十进制表示的字符数组中从$ \texttt{0}$ 到 $\texttt{9}$每个字符的出现次数，然后去哈希表中查找，若存在则说明 $n$ 可以通过重排得到$ 2 $的幂，否则不能。

```java
class Solution {
    Set<String> set = new HashSet<>();
    public boolean reorderedPowerOf2(int n) {
        init();
        return set.contains(countDigits(n));
    }
    private void init() {
        for(int i = 1;i <= 1e9;i<<=1) {
            set.add(countDigits(i));
        }
    }
    private String countDigits(int n) {
        char[] cnt = new char[10];
        while(n > 0) {
            ++cnt[n % 10];
            n /= 10;
        }
        return new String(cnt);
    }
}
```



## [Hard] 335. Self Crossing

You are given an array of integers `distance`.

You start at point `(0,0)` on an **X-Y** plane and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.

Return `true` if your path crosses itself, and `false` if it does not.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg)

```
Input: distance = [2,1,1,2]
Output: true
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross2-plane.jpg)

```
Input: distance = [1,2,3,4]
Output: false
```

**Example 3:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/selfcross3-plane.jpg)

```
Input: distance = [1,1,1,1]
Output: true
```

 

**Constraints:**

- `1 <= distance.length <= 105`
- `1 <= distance[i] <= 105`



### Solution

没考虑到外卷转内卷的情况，没做出来QAQ

题解：

```java
class Solution {
    public boolean isSelfCrossing(int[] distance) {
        int n=distance.length;
        if(n<4) return false;
        int i = 2;

        //外卷
        while(i<n&&distance[i]>distance[i-2]) i++;

        //如果直接干完了，说明不相交
        if(i==n) return false;

        //外卷转内卷，i-1的长度减i-3的长度
        if(distance[i]>=distance[i-2]-(i<4 ? 0:distance[i-4])){
            distance[i-1] -= i<3 ? 0:distance[i-3];
        }
        //一直内卷
        for(++i;i<n&&distance[i]<distance[i-2];i++);

        //如果i能走完说明不相交，否则相交
        return i!=n;
    }
}
```



<span id="260"></span>

## [Medium] 260. Single Number III

Given an integer array `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in **any order**.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

 

**Example 1:**

```
Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
```

**Example 2:**

```
Input: nums = [-1,0]
Output: [-1,0]
```

**Example 3:**

```
Input: nums = [0,1]
Output: [1,0]
```

 

**Constraints:**

- `2 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- Each integer in `nums` will appear twice, only two integers will appear once.



### Solution

利用异或性质

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        /*if(nums.length==2){
            return nums;
        }*/
        int temp=0;
        for(int n:nums){
            temp^=n;
        }
        int temp2=(~temp+1)&temp;//得到最右边的1
        int temp3=temp;
        for(int n:nums){
            if((n&temp2)>0){//那一位是1的
                temp3^=n;
            }
        }
        return new int[]{temp3,temp3^temp};
    }
}
```



## [Easy] 500. Keyboard Row

Given an array of strings `words`, return *the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below*.

In the **American keyboard**:

- the first row consists of the characters `"qwertyuiop"`,
- the second row consists of the characters `"asdfghjkl"`, and
- the third row consists of the characters `"zxcvbnm"`.

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/keyboard.png)

 

**Example 1:**

```
Input: words = ["Hello","Alaska","Dad","Peace"]
Output: ["Alaska","Dad"]
```

**Example 2:**

```
Input: words = ["omk"]
Output: []
```

**Example 3:**

```
Input: words = ["adsdf","sfd"]
Output: ["adsdf","sfd"]
```

### Solution

```java
class Solution {
    static String[] ss = new String[]{"qwertyuiop","asdfghjkl","zxcvbnm"};
    static int[] hash = new int[26];
    static{
        for(int i=0;i<ss.length;i++){
            for(char c:ss[i].toCharArray()){
                hash[c-'a']=i;
            }
        }
    }
    public String[] findWords(String[] words) {
        List<String> list = new ArrayList<String>();
        for(String word : words){
            int idx = hash[Character.toLowerCase(word.charAt(0))-'a'];
            boolean isVaild = true;
            for(int i=1;i<word.length();i++){
                if(hash[Character.toLowerCase(word.charAt(i))-'a']!=idx){
                    isVaild=false;
                    break;
                }
            }
            if(isVaild){
                list.add(word);
            }
        }
        String[] ans = new String[list.size()];
        for(int i=0;i<list.size();i++){
            ans[i]=list.get(i);
        }
        return ans;
    }
}
```



## [Easy] 575. Distribute Candies

Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.

The doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.

Given the integer array `candyType` of length `n`, return *the **maximum** number of different types of candies she can eat if she only eats* `n / 2` *of them*.

 

**Example 1:**

```
Input: candyType = [1,1,2,2,3,3]
Output: 3
Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.
```

**Example 2:**

```
Input: candyType = [1,1,2,3]
Output: 2
Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.
```

**Example 3:**

```
Input: candyType = [6,6,6,6]
Output: 1
Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.
```

 

**Constraints:**

- `n == candyType.length`
- `2 <= n <= 104`
- `n` is even.
- `-105 <= candyType[i] <= 105`

### Solution

Sort

```java
class Solution {
    public int distributeCandies(int[] candyType) {
        Arrays.sort(candyType);
        int count = 1;
        for(int i=1;i<candyType.length;i++){
            if(candyType[i]>candyType[i-1]){
                count++;
            }
        }
        return Math.min(count,candyType.length/2);
    }
}
```



HashSet

```java
class Solution {
    public int distributeCandies(int[] candyType) {
        Set<Integer> m = new HashSet<>();
        for(int type:candyType){
            m.add(type);
        }
        return(Math.min(m.size(),candyType.length/2));
    }
}
```



## [Medium] 130. Surrounded Regions

Given an `m x n` matrix `board` containing `'X'` and `'O'`, *capture all regions that are 4-directionally surrounded by* `'X'`.

A region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

```
Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
```

**Example 2:**

```
Input: board = [["X"]]
Output: [["X"]]
```

 

**Constraints:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 200`
- `board[i][j]` is `'X'` or `'O'`.

### Solution

dfs ! 从边界调DFS，被遍历到的结点为不被X包围的区域内的，未被遍历到的应是被X阻隔导致DFS无法遍历到的，按题意将其置X

```java
class Solution {
    public void solve(char[][] board) {
        if(board.length==1||board.length==0){
            return;
        }
        
        for(int i=0;i<board.length;i++){
            dfs(board,i,0);
            dfs(board,i,board[0].length-1);
        }
        for(int j=1;j<board[0].length-1;j++){
            dfs(board,0,j);
            dfs(board,board.length-1,j);
        }
        
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]=='F'){
                    board[i][j]='O';
                }else if(board[i][j]=='O'){
                    board[i][j]='X';
                }
            }
        }
    }
    private void dfs(char[][] board,int x,int y){
        if(x>=board.length||x<0||y<0||y>=board[0].length||board[x][y]=='F'||board[x][y]=='X')return;
        board[x][y] = 'F';
        dfs(board,x+1,y);
        dfs(board,x-1,y);
        dfs(board,x,y+1);
        dfs(board,x,y-1);
        return;
    }
}
```



## [Easy] 237. Delete Node in a Linked List

Write a function to **delete a node** in a singly-linked list. You will **not** be given access to the `head` of the list, instead you will be given access to **the node to be deleted** directly.

It is **guaranteed** that the node to be deleted is **not a tail node** in the list.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/01/node1.jpg)

```
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/09/01/node2.jpg)

```
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
```

**Example 3:**

```
Input: head = [1,2,3,4], node = 3
Output: [1,2,4]
```

**Example 4:**

```
Input: head = [0,1], node = 0
Output: [1]
```

**Example 5:**

```
Input: head = [-3,5,-99], node = -3
Output: [5,-99]
```

 

**Constraints:**

- The number of the nodes in the given list is in the range `[2, 1000]`.
- `-1000 <= Node.val <= 1000`
- The value of each node in the list is **unique**.
- The `node` to be deleted is **in the list** and is **not a tail** node



### Solution

因为此结点一定不是尾结点，所以可以复制它的下一结点，逻辑删除它的下一结点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val=node.next.val;
        node.next=node.next.next;
    }
}
```



## [Hard] 980. Unique Paths III

You are given an `m x n` integer array `grid` where `grid[i][j]` could be:

- `1` representing the starting square. There is exactly one starting square.
- `2` representing the ending square. There is exactly one ending square.
- `0` representing empty squares we can walk over.
- `-1` representing obstacles that we cannot walk over.

Return *the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/lc-unique1.jpg)

```
Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
Output: 2
Explanation: We have the following two paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```

**Example 2:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/lc-unique2.jpg)

```
Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
Output: 4
Explanation: We have the following four paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2021/08/02/lc-unique3-.jpg)

```
Input: grid = [[0,1],[2,0]]
Output: 0
Explanation: There is no path that walks over every empty square exactly once.
Note that the starting and ending square can be anywhere in the grid.
```

 

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 20`
- `1 <= m * n <= 20`
- `-1 <= grid[i][j] <= 2`
- There is exactly one starting cell and one ending cell.

### Solution

回溯，递归第一层往4个方向dfs，这4个方向可能的路径和即为解。需要在算出当前层可能解之后将矩阵复原，以供上一层的另外的方向搜索；遇到grid\[x\]\[y\]==-1或者越界直接失败，返回0；遇到2判断zero是否都被遍历完了，若是则找到一条路径，返回1，若否，查找失败，返回0；

```java
class Solution {
    public int uniquePathsIII(int[][] grid) {
        int zero=0,x=0,y=0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j<grid[0].length; j++){
                if(grid[i][j]==0){
                    zero++;
                } else if(grid[i][j]==1){
                    x=i;
                    y=j;
                }
            }
        }
        return dfs(grid, x, y, zero);
    }
    private int dfs(int[][] grid , int x, int y, int zero){
        if(x>=grid.length||y>=grid[0].length||x<0||y<0||grid[x][y]==-1){
            return 0;
        }
        if(grid[x][y]==2){
            return (zero==-1)?1:0;
        }
        grid[x][y]=-1;
        zero--;
        int res = dfs(grid,x+1,y,zero)
                + dfs(grid,x,y+1,zero)
                + dfs(grid,x-1,y,zero)
                + dfs(grid,x,y-1,zero);
        grid[x][y]=0;
        zero++;
        return res;
    }
}
```



## [Easy] 129. Sum Root to Leaf Numbers

You are given the `root` of a binary tree containing digits from `0` to `9` only.

Each root-to-leaf path in the tree represents a number.

- For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.

Return *the total sum of all root-to-leaf numbers*. Test cases are generated so that the answer will fit in a **32-bit** integer.

A **leaf** node is a node with no children.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/num1tree.jpg)

```
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

```
Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 1000]`.
- `0 <= Node.val <= 9`
- The depth of the tree will not exceed `10`.

### Solution

DFS again!

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumNumbers(TreeNode root) {
        return dfs(root,0);
    }
    private int dfs(TreeNode root,int sum){
        if(root==null) return 0;
        sum=sum*10+root.val;
        if(root.left==null&&root.right==null){
            return sum;
        }
        return dfs(root.left,sum)+dfs(root.right,sum);
    }
}
```



## [Easy] 404. Sum of Left Leaves

Given the `root` of a binary tree, return the sum of all left leaves.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/leftsum-tree.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
```

**Example 2:**

```
Input: root = [1]
Output: 0
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 1000]`.
- `-1000 <= Node.val <= 1000`

### Solution

连着几天`DFS`了......今天这个还比较绕。需要算所有左叶子节点的值的和。考虑一个`dfs`函数，首先递归出口是结点为null返回0。结点存在且它是左叶子（标记为true并且左右子结点不存在），令它的值加上左边`dfs`(因为只有向左递归调用才有可能找到左叶子，所以令flag=true)和右边`dfs`得到的值为此函数的返回值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        return dfs(root,false);
    }
    private int dfs(TreeNode root,boolean flag){
        if(root==null) return 0;
        return (flag&&root.left==null&&root.right==null)?root.val:0+dfs(root.left,true)+dfs(root.right,false);
    }
}
```



## [Easy] 367. Valid Perfect Square

Given a **positive** integer *num*, write a function which returns True if *num* is a perfect square else False.

**Follow up:** **Do not** use any built-in library function such as `sqrt`.

 

**Example 1:**

```
Input: num = 16
Output: true
```

**Example 2:**

```
Input: num = 14
Output: false
```

 

**Constraints:**

- `1 <= num <= 2^31 - 1`

### Solution

基于二分查找做

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        long l=0,r=num;
        while(l<r){
           long mid = (l+r+1)>>1;
           if(mid*mid<=num) l=mid;
           else r=mid-1; 
        }
        return r*r==num;
    }
}
```



## [Easy] 441. Arranging Coins

You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `ith` row has exactly `i` coins. The last row of the staircase **may be** incomplete.

Given the integer `n`, return *the number of **complete rows** of the staircase you will build*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/arrangecoins1-grid.jpg)

```
Input: n = 5
Output: 2
Explanation: Because the 3rd row is incomplete, we return 2.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg)

```
Input: n = 8
Output: 3
Explanation: Because the 4th row is incomplete, we return 3.
```

 

**Constraints:**

- `1 <= n <= 231 - 1`

### Solution

暴力

```java
class Solution {
    public int arrangeCoins(int n) {
        int i=1;
        while(n>0){
            i++;
            n=n-i;
        }
        return i-1;
    }
}
```

数学归纳

```java
class Solution {
    public int arrangeCoins(int n) {
        return (int) (Math.sqrt(2 * (long) n + 0.25) - 0.5);
    }
}
```



## [Medium] 260

[Go to](#260)



## [Easy] 268. Missing Number

Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return *the only number in the range that is missing from the array.*

 

**Example 1:**

```
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
```

**Example 2:**

```
Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
```

**Example 3:**

```
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
```

**Example 4:**

```
Input: nums = [0]
Output: 1
Explanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 104`
- `0 <= nums[i] <= n`
- All the numbers of `nums` are **unique**.

 

**Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?

### Solution

首先想到数学法,  时间O(n) 空间O(1)

```java
class Solution {
    public int missingNumber(int[] nums) {
        int sum1=0,n=nums.length;
        for(int i=0;i<n;i++){
            sum1+=nums[i];
        }
        return n*(n+1)/2-sum1;
    }
}
```

还能用异或做，时间O(n) 空间O(1)

```java
class Solution {
    public int missingNumber(int[] nums) {
        int temp=nums[0],n=nums.length;
        for(int i=1;i<n;i++) temp^=nums[i];
        for(int i=0;i<=n;i++) temp^=i;
        return temp;
    }
}
```



## [Hard] 23. Merge k Sorted Lists

You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

*Merge all the linked-lists into one sorted linked-list and return it.*

 

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

 

**Constraints:**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` is sorted in **ascending order**.
- The sum of `lists[i].length` won't exceed `10^4`.

### Solution

归并, 硬搞

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length<=0) return null;
        return process(lists, 0, lists.length - 1);
    }
    private static ListNode process(ListNode[] list ,int l, int r) {
        if(l==r){
            return list[l];
        }
        int mid =  (l + r) >> 1;
        ListNode L=process(list,l,mid);
        ListNode R=process(list,mid + 1,r);
        return merge(L,R);
    }
    private static ListNode merge(ListNode a, ListNode b) {
        ListNode fuck = new ListNode(-1);
        ListNode cur = fuck;
        while(a != null && b != null) {
            if(a.val < b.val) {
                cur.next = a;
                a = a.next;
            } else {
                cur.next = b;
                b = b.next;
            }
            cur = cur.next;
        }
        if(a != null) {
            cur.next = a;
        }
        if(b != null) {
            cur.next = b;
        }
        return fuck.next;
    }
}
```



## [Easy] 88. Merge Sorted Array

You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.

**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.

The final sorted array should not be returned by the function, but instead be *stored inside the array* `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.

 

**Example 1:**

```
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
```

**Example 2:**

```
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
```

**Example 3:**

```
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
```

 

**Constraints:**

- `nums1.length == m + n`
- `nums2.length == n`
- `0 <= m, n <= 200`
- `1 <= m + n <= 200`
- `-109 <= nums1[i], nums2[j] <= 109`

 

**Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?

### Solution

练习归并，时间空间都是O(m+n)

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] temp = new int[m+n];
        if(n==0) return;
        int p1=0,p2=0,i=0;
        if(m==0){
            for(int f:nums2){
                nums1[i++]=f;
            }
            return;
        }
        while(p1<m&&p2<n){
            temp[i++] = nums1[p1]<nums2[p2]?nums1[p1++]:nums2[p2++];
        }
        while(p1<m){
            temp[i++] = nums1[p1++];
        }
        while(p2<n){
            temp[i++] = nums2[p2++];
        }
        i=0;
        for(int k:temp){
            nums1[i++]=k;
        }
    }
}
```



## [Medium] 43. Multiply Strings

Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.

**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.

 

**Example 1:**

```
Input: num1 = "2", num2 = "3"
Output: "6"
```

**Example 2:**

```
Input: num1 = "123", num2 = "456"
Output: "56088"
```

 

**Constraints:**

- `1 <= num1.length, num2.length <= 200`
- `num1` and `num2` consist of digits only.
- Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.

### Solution

```java
class Solution {
    public String multiply(String num1, String num2) {
        int n1=num1.length();
        int n2=num2.length();
        if(n1<=0||n2<=0) return "";
        int[] temp = new int[n1+n2];//临时数组
        for(int i=n1-1;i>=0;--i) {
            for(int j=n2-1;j>=0;--j) {
                int fuck = (num1.charAt(i)-'0')*(num2.charAt(j)-'0');
                fuck+=temp[i+j+1];//加上低位判断是否产生进位
                temp[i+j]+=fuck/10;//进位
                temp[i+j+1]=fuck%10;
            }
        }
        StringBuilder sb = new StringBuilder();
        int index=0;
        while(index<temp.length-1&&temp[index]==0){//去掉Leading 0s
            index++;
        }
        for(;index<temp.length;index++){//拷贝到sb里
            sb.append(temp[index]);
        }
        return sb.toString();
    }
}
```



## [Easy] 598. Range Addition II

You are given an `m x n` matrix `M` initialized with all `0`'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means `M[x][y]` should be incremented by one for all `0 <= x < ai` and `0 <= y < bi`.

Count and return *the number of maximum integers in the matrix after performing all the operations*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/ex1.jpg)

```
Input: m = 3, n = 3, ops = [[2,2],[3,3]]
Output: 4
Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.
```

**Example 2:**

```
Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]
Output: 4
```

**Example 3:**

```
Input: m = 3, n = 3, ops = []
Output: 9
```

 

**Constraints:**

- `1 <= m, n <= 4 * 104`
- `0 <= ops.length <= 104`
- `ops[i].length == 2`
- `1 <= ai <= m`
- `1 <= bi <= n`

### Solution

脑筋急转弯，跟矩阵无关，处理下标即可

```java
class Solution {
    public int maxCount(int m, int n, int[][] ops) {
        for(int[] op : ops){
            m=Math.min(m,op[0]);
            n=Math.min(n,op[1]);
        }
        return m*n;
    }
}
```



## [Medium] 96. Unique Binary Search Trees

Given an integer `n`, return *the number of structurally unique **BST'**s (binary search trees) which has exactly* `n` *nodes of unique values from* `1` *to* `n`.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/uniquebstn3.jpg)

```
Input: n = 3
Output: 5
```

**Example 2:**

```
Input: n = 1
Output: 1
```

 

**Constraints:**

- `1 <= n <= 19`

### Solution

动态规划，$dp(n) = dp(0)\times dp(n-1) +dp(1)\times dp(n-2) + dp(2)\times dp(n-3) + ...... + dp(n-3)\times dp(2) +dp(n-2)\times dp(1) + dp(n-1)\times dp(0)$

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[i-j]*dp[j-1];
            }
        }
        return dp[n];
    }
}
```



## [Medium] 299. Bulls and Cows

You are playing the **[Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows)** game with your friend.

You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:

- The number of "bulls", which are digits in the guess that are in the correct position.
- The number of "cows", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.

Given the secret number `secret` and your friend's guess `guess`, return *the hint for your friend's guess*.

The hint should be formatted as `"xAyB"`, where `x` is the number of bulls and `y` is the number of cows. Note that both `secret` and `guess` may contain duplicate digits.

 

**Example 1:**

```
Input: secret = "1807", guess = "7810"
Output: "1A3B"
Explanation: Bulls are connected with a '|' and cows are underlined:
"1807"
  |
"7810"
```

**Example 2:**

```
Input: secret = "1123", guess = "0111"
Output: "1A1B"
Explanation: Bulls are connected with a '|' and cows are underlined:
"1123"        "1123"
  |      or     |
"0111"        "0111"
Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.
```

**Example 3:**

```
Input: secret = "1", guess = "0"
Output: "0A0B"
```

**Example 4:**

```
Input: secret = "1", guess = "1"
Output: "1A0B"
```

 

**Constraints:**

- `1 <= secret.length, guess.length <= 1000`
- `secret.length == guess.length`
- `secret` and `guess` consist of digits only.

### Solution

我不觉得简单的简单模拟题

```java
class Solution {
    public String getHint(String secret, String guess) {
        int[] cnt1 = new int[10], cnt2 = new int[10];
        int a=0,b=0;
        for(int i=0;i<secret.length();i++) {
            int c1=secret.charAt(i)-'0',c2=guess.charAt(i)-'0';
            if(c1==c2) {
                a++;
            } else {
                cnt1[c1]++;
                cnt2[c2]++;
            }
        }
        for(int i=0;i<10;i++) b+=Math.min(cnt1[i],cnt2[i]);
        return a+"A"+b+"B";
    }
}
```



## [Easy] 70. Climbing Stairs

You are climbing a staircase. It takes `n` steps to reach the top.

Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

 

**Example 1:**

```
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```

**Example 2:**

```
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

 

**Constraints:**

- `1 <= n <= 45`

### Solution

```java
class Solution {
    public int climbStairs(int n) {
        if(n<=3) return n;
        int a=2,b=3,c=a+b;
        for(int i=4;i<=n;i++){
            c=a+b;
            a=b;
            b=c;
        }
        return c;
    }
}
```



## [Easy] 746. Min Cost Climbing Stairs

You are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index `0`, or the step with index `1`.

Return *the minimum cost to reach the top of the floor*.

 

**Example 1:**

```
Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.
```

**Example 2:**

```
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.
```

 

**Constraints:**

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

### Solution

用$dp[i]$表示到第$i$级台阶的最小代价

状态转移方程： $dp[i]=min(dp[i-2]+cost[i-2],dp[i-1]+cost[i-1])$

由于到当前台阶的代价只与它前两级的代价有关，所以可以只用三个变量

初值：$dp[0]=dp[1]=0;$

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int a=0,b=0,c=0;
        for(int i=2;i<=cost.length;i++){
            c=Math.min(a+cost[i-2],b+cost[i-1]);
            a=b;
            b=c;
        }
        return c;
    }
}
```

## [Hard] 1178. Number of Valid Words for Each Puzzle

With respect to a given `puzzle` string, a `word` is *valid* if both the following conditions are satisfied:

- `word` contains the first letter of `puzzle`.

- For each letter in `word`, that letter is in `puzzle`.

  - For example, if the puzzle is `"abcdefg"`, then valid words are `"faced"`, `"cabbage"`, and `"baggage"`, while
- invalid words are `"beefed"` (does not include `'a'`) and `"based"` (includes `'s'` which is not in the puzzle).

Return *an array* `answer`*, where* `answer[i]` *is the number of words in the given word list* `words` *that is valid with respect to the puzzle* `puzzles[i]`. 

**Example 1:**

```
Input: words = ["aaaa","asas","able","ability","actt","actor","access"], puzzles = ["aboveyz","abrodyz","abslute","absoryz","actresz","gaswxyz"]
Output: [1,1,3,2,4,0]
Explanation: 
1 valid word for "aboveyz" : "aaaa" 
1 valid word for "abrodyz" : "aaaa"
3 valid words for "abslute" : "aaaa", "asas", "able"
2 valid words for "absoryz" : "aaaa", "asas"
4 valid words for "actresz" : "aaaa", "asas", "actt", "access"
There are no valid words for "gaswxyz" cause none of the words in the list contains letter 'g'.
```

**Example 2:**

```
Input: words = ["apple","pleas","please"], puzzles = ["aelwxyz","aelpxyz","aelpsxy","saelpxy","xaelpsy"]
Output: [0,1,3,2,0]
```

**Constraints:**

- `1 <= words.length <= 105`
- `4 <= words[i].length <= 50`
- `1 <= puzzles.length <= 104`
- `puzzles[i].length == 7`
- `words[i]` and `puzzles[i]` consist of lowercase English letters.
- Each `puzzles[i] `does not contain repeated characters.



### Solution 

憋不出来的Hard.......

$HashMap$和位运算

`a >> b & 1` 代表检查 a 的第 b 位是否为 1，有两种可能性 0 或者 1

`a += 1 << b` 代表将 a 的第 b 位设置为 1 (当第 b 位为 0 的时候适用)

如不想写对第 b 位为 0 的前置判断，`a += 1 << b` 也可以改成 `a |= 1 << b`

```java
class Solution {
    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {
        Map<Integer , Integer> map = new HashMap<>();
        for(String w : words) {
            int t = getBin(w);
            map.put(t, map.getOrDefault(t, 0) + 1);
        }
        List<Integer> ans = new ArrayList<Integer>();
        for(String p : puzzles) ans.add(getCnt(map, p));
        return ans;
    }
    // 统计string的字符，返回一个26位的二进制数（其实是32位，只用26位），表示每个字母是否出现，出现的位置标1
    private static int getBin(String str) {
        char[] cs = str.toCharArray();
        int res = 0;
        for(char c : cs) {
            // 每一位字符所对应二进制数字中哪一位
            int t = c - 'a';
            // 不重复地记录字符
            if((res >> t & 1) == 0) res += 1 << t; 
        }
        return res;
    }
    private static int getCnt(Map<Integer, Integer> map, String str) {
        int ans = 0;
        int m = str.length();
        char[] cs = str.toCharArray();
        // 首字母在二进制数值中的位置
        int first = cs[0] - 'a';t
        for(int i = 0; i < (1 << (m - 1)); i++) {
            // t 代表了当前可能的谜底。先将首字母提取出来
            int t = 1 << first;
            // 枚举「首个字母」之后的每一位
            for(int j = 1; j < m; j++) {
                // 如果当前位为 1，代表该位置要保留，将该位置的字母追加到谜底 t 中
                if((i >> (j-1) & 1) == 1) t += 1 << (cs[j]-'a');
            }
            // 查询这样的词出现了多少次
            if(map.containsKey(t)) ans += map.get(t);
        }
        return ans;
    }
}
```



## [Medium] 198. House Robber  

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

 

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 2:**

```
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
```

 

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

### Solution

  动态规划！

  考虑当前这家抢还是不抢，抢的话获得的\$是当前这家加上考虑从它下下家开始能获得的最大金额，不抢的话获得的是从它下一家开始考虑能获得的最大金额。

  写成状态转移方程：

  $dp[i] = max(dp[i+1], dp[i+2]+money[i])$

```java
class Solution {
    public int rob(int[] nums) {
        int[] dp = new int[nums.length+2];
        for(int i=nums.length-1;i>=0;i--) {
            dp[i] = Math.max(dp[i+1],dp[i+2]+nums[i]);
        }
        return dp[0];
    }
}
```

空间优化：

```java
class Solution {
    public int rob(int[] nums) {
        int pre = 0, cur = 0;
        for(int num : nums) {
            int max = Math.max(cur, pre + num);
            pre = cur;
            cur = max;
        }
        return cur;
    }
}
```



## [Medium] 213. House Robber II

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.

 

**Example 1:**

```
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
```

**Example 2:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

**Example 3:**

```
Input: nums = [1,2,3]
Output: 3
```

 

**Constraints:**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`

### Solution

环形的，考虑`抢第一家不抢最后一家`和`抢最后一家不抢第一家`还有`第一家最后一家都不抢`（这种情况包括在抢最后一家不抢第一家里）

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length==1) return nums[0];
        return Math.max(robRange(nums, 0, nums.length - 2) , robRange(nums, 1, nums.length-1) );
    }
    private static int robRange(int[] nums, int start, int end) {
        int pre = 0;
        int cur = 0;
        for(int i = start;i <= end; i++) {
            int temp = Math.max(cur, nums[i] + pre);
            pre = cur;
            cur = temp;
        }
        return cur;
    }
}
```



## [Medium] 740. Delete and Earn

You are given an integer array `nums`. You want to maximize the number of points you get by performing the following operation any number of times:

- Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards, you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.

Return *the **maximum number of points** you can earn by applying the above operation some number of times*.

 

**Example 1:**

```
Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
```

**Example 2:**

```
Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.
```

 

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `1 <= nums[i] <= 104`

### Solution

可以转化为打家劫舍问题。

Delete 3 可以得到3 点，并且失去Delete 2 和4 的机会，但是还能继续Delete 3 获得3 点。

根据这个性质设计另一个数组，储存所有相同数值数的和，比如对[2,2,3,3,4]设计一个[0,0,4,6,4]

得到的数组就可以按照打家劫舍问题来做了（相邻的点数不能同时获得）

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int max = 0;
        for(int num : nums) {
            if(num>max) max = num;
        }
        int[] temp = new int[max+1];
        for(int num : nums) {
            temp[num] += num;
        }
        return rob(temp);
    }
    private static int rob(int[] nums) {
        int pre = 0;
        int cur = 0;
        for(int num : nums) {
            int temp = Math.max(cur, pre + num);
            pre = cur;
            cur = temp;
        }
        return cur;
    }
}
```



## [Easy] 495. Teemo Attacking

Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly `duration` seconds. More formally, an attack at second `t` will mean Ashe is poisoned during the **inclusive** time interval `[t, t + duration - 1]`. If Teemo attacks again **before** the poison effect ends, the timer for it is **reset**, and the poison effect will end `duration` seconds after the new attack.

You are given a **non-decreasing** integer array `timeSeries`, where `timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]`, and an integer `duration`.

Return *the **total** number of seconds that Ashe is poisoned*.

 

**Example 1:**

```
Input: timeSeries = [1,4], duration = 2
Output: 4
Explanation: Teemo's attacks on Ashe go as follows:
- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.
Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.
```

**Example 2:**

```
Input: timeSeries = [1,2], duration = 2
Output: 3
Explanation: Teemo's attacks on Ashe go as follows:
- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.
Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.
```

 

**Constraints:**

- `1 <= timeSeries.length <= 104`
- `0 <= timeSeries[i], duration <= 107`
- `timeSeries` is sorted in **non-decreasing** order.

### Solution

```java
class Solution {
    public int findPoisonedDuration(int[] ts, int d) {
        int ans=0,pre=-1;
        for(int t:ts){
            ans+=pre<t?d:t+d-1-pre;
            pre = t+d-1;
        }
        return ans;
    }
}
```



## [Medium] 122. Best Time to Buy and Sell Stock II

You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

On each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.

Find and return *the **maximum** profit you can achieve*.

 

**Example 1:**

```
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
```

**Example 2:**

```
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
```

**Example 3:**

```
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.
```

 

**Constraints:**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

### Solution

Easy solution:

```java
class Solution {
    public int maxProfit(int[] prices) {
        int sum = 0;
        for(int i = 1; i < prices.length; i++) sum += (prices[i] - prices[i - 1] > 0 )?prices[i] - prices[i - 1]:0;
        return sum;
    }
}
```

DP solution:

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int s0 = 0, s1 = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            int temp = s0;
            s0 = Math.max(s0, s1 + prices[i]);
            s1 = Math.max(s1, temp - prices[i]);
        }
        return s0;
    }
}
```

## [Easy] 53. Maximum Subarray 

Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return *its sum*.

A **subarray** is a **contiguous** part of an array.

 

**Example 1:**

```
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

**Example 2:**

```
Input: nums = [1]
Output: 1
```

**Example 3:**

```
Input: nums = [5,4,-1,7,8]
Output: 23
```

 

**Constraints:**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

### Solution

$dp$数组记录下以`nums[i]`结尾的最大子数组和

状态转移方程推导：`dp[i]` 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        for(int i= 1; i < nums.length; i++) {
            dp[i] = Math.max(nums[i], nums[i]+dp[i-1]);
        }
        int max = dp[0];
        for(int i = 0; i < dp.length; i++) {
            max=Math.max(dp[i], max);
        }
        return max;
    }
}
```

空间优化

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int dp_0 = nums[0];
        int dp_1 = 0;
        int max = dp_0;
        for(int i= 1; i < nums.length; i++) {
            dp_1 = Math.max(nums[i], nums[i]+dp_0);
            dp_0 = dp_1;
            max = Math.max(dp_1,max);
        }
        
        return max;
    }
}
```



## [Medium] 918. Maximum Sum Circular Subarray

Given a **circular integer array** `nums` of length `n`, return *the maximum possible sum of a non-empty **subarray** of* `nums`.

A **circular array** means the end of the array connects to the beginning of the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`.

A **subarray** may only include each element of the fixed buffer `nums` at most once. Formally, for a subarray `nums[i], nums[i + 1], ..., nums[j]`, there does not exist `i <= k1`, `k2 <= j` with `k1 % n == k2 % n`.

 

**Example 1:**

```
Input: nums = [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3
```

**Example 2:**

```
Input: nums = [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10
```

**Example 3:**

```
Input: nums = [3,-1,2,-1]
Output: 4
Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4
```

**Example 4:**

```
Input: nums = [3,-2,2,-3]
Output: 3
Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3
```

**Example 5:**

```
Input: nums = [-2,-3,-1]
Output: -1
Explanation: Subarray [-1] has maximum sum -1
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`

### Solution

最大子序和在两边：全部的和减去中间求得的最小子序和

最大子序和在中间：和53题一样

```java
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int dp_1 = nums[0];
        int dp_11 = nums[0];
        int min = dp_1;
        int max = dp_1;
        int sum = dp_1;
        for(int i = 1; i < nums.length; i++) {
            dp_1 =nums[i]<(dp_1+nums[i])?nums[i]:(dp_1+nums[i]);
            dp_11 = nums[i]>(dp_11+nums[i])?nums[i]:(dp_11+nums[i]);
            min = min< dp_1?min:dp_1;
            max = max>dp_11?max:dp_11;
            sum+=nums[i];
        }
        if(max<0)return max;
        return max>(sum-min)?max:sum-min;
    }
}
```



## [Medium] 55. Jump Game

You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.

Return `true` *if you can reach the last index, or* `false` *otherwise*.

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
```

**Constraints:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`



### Solution

贪心！看最多能跳到哪儿，如果最远能超过数组的last index（注意是last index），返回true

```java
class Solution {
    public boolean canJump(int[] nums) {
        int max = 0;
        for(int i = 0; i < nums.length - 1; i++) {
            max = max > nums[i] + i ? max : nums[i] + i;
            if(max <= i) {
                return false;
            }
        }
        return max >= nums.length-1;
    }
}
```



## [Medium] 45. Jump Game II

Given an array of non-negative integers `nums`, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

You can assume that you can always reach the last index.

**Example 1:**

```
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: nums = [2,3,0,1,4]
Output: 2
```

**Constraints:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`

### Solution

从0开始贪心到能到达的最大位置，这个位置与某一次循环的下标重合时，说明跳了一次计数器加一

```java
class Solution {
    public int jump(int[] nums) {
        int max = 0, end = 0, ans = 0;
        for(int i = 0; i < nums.length - 1; i++) {
            max = max > nums[i] + i ? max : nums[i] + i;
            if(end == i) {
                ans++;
                end = max;
            }
        }
        return ans;
    }
}
```



## [Medium] 152. Maximum Product Subarray

Given an integer array `nums`, find a contiguous non-empty subarray within the array that has the largest product, and return *the product*.

It is **guaranteed** that the answer will fit in a **32-bit** integer.

A **subarray** is a contiguous subsequence of the array.

**Example 1:**

```
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
```

**Example 2:**

```
Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
```

**Constraints:**

- `1 <= nums.length <= 2 * 104`
- `-10 <= nums[i] <= 10`
- The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.



### Solution

记录乘积最大值和乘积最小值，遇到负数，两数交换，保证无论正负，在计算乘积最大值时得到的一定是最大的

```java
class Solution {
    public int maxProduct(int[] nums) {
        int pre = nums[0],pre1 = nums[0],max=nums[0];
        for(int i=1;i<nums.length;i++) {
            if(nums[i]<0){
                pre = pre^pre1;
                pre1 = pre^pre1;
                pre = pre^pre1;
            }
            pre = nums[i]>nums[i]*pre?nums[i]:nums[i]*pre;
            pre1 = nums[i]<nums[i]*pre1?nums[i]:nums[i]*pre1;
            max = max>pre?max:pre;
        }
        return max;
    }
}
```



## [Medium] 1567. Maximum Length of Subarray With Positive Product

Given an array of integers `nums`, find the maximum length of a subarray where the product of all its elements is positive.

A subarray of an array is a consecutive sequence of zero or more values taken out of that array.

Return *the maximum length of a subarray with positive product*.

 

**Example 1:**

```
Input: nums = [1,-2,-3,4]
Output: 4
Explanation: The array nums already has a positive product of 24.
```

**Example 2:**

```
Input: nums = [0,1,-2,-3,-4]
Output: 3
Explanation: The longest subarray with positive product is [1,-2,-3] which has a product of 6.
Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.
```

**Example 3:**

```
Input: nums = [-1,-2,-3,0,1]
Output: 2
Explanation: The longest subarray with positive product is [-1,-2] or [-2,-3].
```

**Example 4:**

```
Input: nums = [-1,2]
Output: 1
```

**Example 5:**

```
Input: nums = [1,2,3,5,-6,4,0,10]
Output: 4
```

 

**Constraints:**

- `1 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

### Solution

可以使用动态规划得到乘积为正数的最长子数组长度。定义两个数组 $\textit{positive}$ 和 $\textit{negative}$，其中$ \textit{positive}[i]$表示以下标 i*i* 结尾的乘积为正数的最长子数组长度，$\textit{negative}[i]$ 表示乘积为负数的最长子数组长度。

当 $i=0$时，以下标 $i$ 结尾的子数组的长度为 $1$因此当 $\textit{nums}[0]>0$ 时 $\textit{positive}[0]=1$，当 $\textit{nums}[0]<0$ 时 $\textit{negative}[0]=1$。

当 $i>1$ 时，根据 $\textit{nums}[i]$ 的值计算 $\textit{positive}[i]$ 和 $\textit{negative}[i]$ 的值。

- 当 $\textit{nums}[i]>0$ 时，之前的乘积乘以 $\textit{nums}[i]$ 不会改变乘积的正负性。

  $\textit{positive}[i]$的计算为：

  $\textit{positive}[i]=\textit{positive}[i-1]+1$

  $\textit{negative}[i]$ 的计算为：

  $\textit{negative}[i]=\begin{cases} \textit{negative}[i-1]+1, & \textit{negative}[i-1]>0 \\ 0, & \textit{negative}[i-1] = 0 \end{cases}$

  这是因为当 $\textit{negative}[i-1]=0$ 时，$\textit{negative}[i]$ 本身无法形成一个乘积为正数的子数组，所以要特殊判断。

- 当 $\textit{nums}[i]<0$ 时，之前的乘积乘以 $\textit{nums}[i]$ 会改变乘积的正负性。

  $\textit{positive}[i]$的计算为：

  $\textit{positive}[i]=\begin{cases} \textit{negative}[i-1]+1, & \textit{negative}[i-1]>0 \\ 0, & \textit{negative}[i-1] = 0 \end{cases}$

  这是因为当 $\textit{negative}[i-1]=0$ 时，$\textit{positive}[i]$本身无法形成一个乘积为负数的子数组，所以要特殊判断。

  $\textit{negative}[i]$ 的计算为：

  $\textit{negative}[i]=\textit{positive}[i-1]+1$

- 当 $\textit{nums}[i]=0$ 时，以下标 i*i* 结尾的子数组的元素乘积一定为 $0$，因此有 $\textit{positive}[i]=0$和 $\textit{negative}[i]=0$。

在计算 $\textit{positive}$和 $\textit{negative}$两个数组的过程中维护乘积为正数的最长子数组长度，当遍历结束时，即可得到最长子数组长度。

```java
class Solution {
    public int getMaxLen(int[] nums) {
        int pos = nums[0]>0?1:0;
        int neg = nums[0]<0?1:0;
        int max = pos;
        for(int i=1;i<nums.length;i++) {
            if(nums[i]>0) {
                pos++;
                neg = neg>0?neg+1:0;
            } else if(nums[i]<0) {
                int temp = pos+1;
                pos = neg>0?neg+1:0;
                neg = temp;
            } else {
                neg = 0;
                pos = 0;
            }
            max = max>pos ? max:pos;
        }
        return max;
    }
}
```

## [Medium] 739. Daily Temperatures

单调栈效果贼拉，复盘一下

[见Data_Structure](./2021-9-15-Data_Structure.md/#leetcode-739-daily-temperatures)

























# tricks

## 多数问题：摩尔投票法

 Boyer-Moore Voting Algorithm, 又称为多数投票法，摩尔投票法的一大应用就是**求众数**。

  摩尔投票法基于这样一个事实，**当一个数的重复次数超过数组长度的一半，每次将两个不相同的数删除，最终剩下的就是要找的数。**

摩尔投票法分为两个阶段：**抵消阶段和计数阶段**。

  **抵消阶段**：两个不同投票进行对坑，并且同时抵消掉各一张票，如果两个投票相同，则累加可抵消的次数；

  **计数阶段**：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定。

==算法步骤==：

1. `count = 0；` ` num = nums[0];` 表示从此时开始计算投票。

2. 遍历数组，如果接下来出现的数字与`num`相同，`count`加1。如果不同，`count`减1。

3. 如果`count == 0`，表示之前出现的所有数字中`num`都是可以凑成不同的数对，一起抵消。大于`1/2 n`的数还会在后面出现。

4. 如果`count < 0`，表示之前`num`中的数字没有到一半，所以此时完全不用考虑前面存储的元素，“删除”他们。直接从现在的新的元素开始计数，并令`count = 0`。

对于出现超过`n/2`次数的元素：

```java
class Solution {
    public int majorityElement(int[] nums) {
        int vote = 0, element = 0;
        for(int num : nums) {
            if(vote > 0 && num == element) {
                vote++;
            } else if(vote==0) {
                vote++;
                element = num;
            } else {
                vote--;
            }
        }
        return element;
    }
}
```

对于出现超过`n/3`次数的元素：

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> ans;
        int vote1 = 0, vote2 = 0, element1 = 0, element2 = 0;
        for(int num : nums) {
            if(vote1 > 0 && num == element1){
                vote1++;
            } else if(vote2 > 0 && num == element2) {
                vote2++;
            } else if(vote1 == 0) {
                vote1++;
                element1 = num;
            } else if (vote2==0) {
                vote2++;
                element2 = num;
            } else {
                vote2--;
                vote1--;
            }
        }

        int count1 = 0, count2 = 0;
        for(int num : nums) {
            if(vote1 > 0 && num == element1) {
                count1++;
            }
            if(vote2 > 0 && num == element2) {
                count2++;
            }
        }

        ans = new ArrayList<>();
        if(vote1 > 0 && count1 > nums.length / 3){
            ans.add(element1);
        }
        if(vote2 > 0 && count2 > nums.length / 3){
            ans.add(element2);
        }
        
        return ans;
    }
}
```

可以扩展至找出出现次数超过`1/k`次的元素的问题：

**至多选出m个代表，每个选票数大于n / (m + 1)**







## 折半查找/二分搜索

对于有序的数组，优先考虑这个

## 单调栈



## DFS







## 异或

### 性质：

**[交换律](https://zh.wikipedia.org/wiki/交换律)**：![{\displaystyle p\oplus q=q\oplus p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/110615f4e2eac3794ceff1a3ce124c514edcbe21)

**[结合律](https://zh.wikipedia.org/wiki/结合律)**：![{\displaystyle p\oplus (q\oplus r)=(p\oplus q)\oplus r}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2bd7e13889de806aef9c852cf7d4679aa869c66d)

**恒等律**：![{\displaystyle p\oplus 0=p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2b51c3409f9ec2458c703a0e197a0f8be35107f6)

**归零律**：![{\displaystyle p\oplus p=0}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b344ce1ebeb618481da59f2894dea398cf1503aa)

**[自反](https://zh.wikipedia.org/wiki/自反关系)**： ![{\displaystyle p\oplus q\oplus q=p\oplus 0=p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/62d8e0ecddcbe17c8b1fd9dbf00aff0c3083ee4e)

### 用法

根据自反或者归零的性质，异或常用于找缺失数、找出现一次数、找出现奇数次数之类的应用。还可用于不引入临时变量的交换。

#### 例：

Swap:

```java
private void swap(int[] nums, int i, int j){
    if(i!=j) {//同一地址异或会归零，交换时应避免出现相同地址的元素交换。
    	nums[i]=nums[i]^nums[j];
        nums[j]=nums[i]^nums[j];
        nums[i]=nums[i]^nums[j];
    }
}
```

Single Number(在同一数字最多出现两次的数组中，找到只出现过一次的数字):

```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for(int num:nums) ans^=num;
        return ans;
    }
}
```

Single Number的进阶版，[260题](#260)

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        /*if(nums.length==2){
            return nums;
        }*/
        int temp=0;
        for(int n:nums){
            temp^=n;
        }
        int temp2=(~temp+1)&temp;//得到最右边的1
        int temp3=temp;
        for(int n:nums){
            if((n&temp2)>0){//那一位是1的
                temp3^=n;
            }
        }
        return new int[]{temp3,temp3^temp};
    }
}
```



## DP

