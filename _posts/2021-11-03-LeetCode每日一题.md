---
redirect_from: /_posts/2021-11-03-LeetCode每日一题.md/
title: LeetCode每日一题
tags:
  - Java
  - DataStructure
---
# 每日一题

## [Easy] 453. Minimum Moves to Equal Array Elements

Given an integer array `nums` of size `n`, return *the minimum number of moves required to make all array elements equal*.

In one move, you can increment `n - 1` elements of the array by `1`.

 

**Example 1:**

```
Input: nums = [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements):
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```

**Example 2:**

```
Input: nums = [1,1,1]
Output: 0
```

 

**Constraints:**

- `n == nums.length`
- `1 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`
- The answer is guaranteed to fit in a **32-bit** integer.

### My solution

n-1个元素增加一，相当于剩下的一个元素减小1。只需找到最小的元素，移动次数即为最小元素与各个元素的差的和；

```java
class Solution {
    public int minMoves(int[] nums) {
        // Arrays.sort(nums);
        // int minnum = nums[0];
        int minnum = Arrays.stream(nums).min().getAsInt();
        int res=0;
        for(int i=0;i<nums.length;i++){
            res+=nums[i]-minnum;
        }
        return res;
    }
}
```

优化后：

```java
class Solution {
    public int minMoves(int[] nums) {
        int minnum = nums[0];
        int sum=minnum;
        for(int i=1;i<nums.length;i++){
            if(nums[i]<minnum){
                minnum = nums[i];
            }
            sum+=nums[i];
        }
        return sum-minnum*nums.length;
    }
}
```





## [Medium] 151. Reverse Words in a String

Given an input string `s`, reverse the order of the **words**.

A **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.

Return *a string of the words in reverse order concatenated by a single space.*

**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

 

**Example 1:**

```
Input: s = "the sky is blue"
Output: "blue is sky the"
```

**Example 2:**

```
Input: s = "  hello world  "
Output: "world hello"
Explanation: Your reversed string should not contain leading or trailing spaces.
```

**Example 3:**

```
Input: s = "a good   example"
Output: "example good a"
Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.
```

**Example 4:**

```
Input: s = "  Bob    Loves  Alice   "
Output: "Alice Loves Bob"
```

**Example 5:**

```
Input: s = "Alice does not even like bob"
Output: "bob like even not does Alice"
```

 

**Constraints:**

- `1 <= s.length <= 104`
- `s` contains English letters (upper-case and lower-case), digits, and spaces `' '`.
- There is **at least one** word in `s`.

 

**Follow-up:** If the string data type is mutable in your language, can you solve it **in-place** with `O(1)` extra space?



### Solution

使用库函数

```java
class Solution {
    public String reverseWords(String s) {
        String[] res = s.trim().split(" +");
        Collections.reverse(Arrays.asList(res));
        return String.join(" ", res);
    }
}
```

O(1) extra space 解法

- 去除多余的空格

- 把每一个单词逆置
- 再把整个字符串翻转

```java
class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = removeSpace(s);
        reverseEverything(sb,0,sb.length()-1);
        reverseEachWord(sb);
        return sb.toString();
    }
    
    private StringBuilder removeSpace(String s) {
        int start = 0, end = s.length()-1;
        while(s.charAt(start)==' ') {
            start++;
        }
        while(s.charAt(end)==' ') {
            end--;
        }
        StringBuilder sb = new StringBuilder();
        while(start<=end) {
            char c = s.charAt(start);
            if(c != ' '||sb.charAt(sb.length()-1) != ' ') {
                sb.append(c);
            }
            start++;
        }
        return sb;
    }
    
    private void reverseEverything(StringBuilder sb, int start, int end) {
        while(start<end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
        }
        
    }
    
    private void reverseEachWord(StringBuilder sb) {
        int start = 0, end = 1;
        while(start < sb.length()) {
            while((end<sb.length())&&(sb.charAt(end)!=' ')) {
                end++;
            }
            reverseEverything(sb,start,end-1);
            start = end+1;
            end = start+1;
        }
    }
}
```



## [Easy] 66. Plus One

You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.

Increment the large integer by one and return *the resulting array of digits*.

 

**Example 1:**

```
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].
```

**Example 2:**

```
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].
```

**Example 3:**

```
Input: digits = [0]
Output: [1]
Explanation: The array represents the integer 0.
Incrementing by one gives 0 + 1 = 1.
Thus, the result should be [1].
```

**Example 4:**

```
Input: digits = [9]
Output: [1,0]
Explanation: The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].
```

 

**Constraints:**

- `1 <= digits.length <= 100`
- `0 <= digits[i] <= 9`
- `digits` does not contain any leading `0`'s.

### My Solution

直接模拟

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int temp=1;
        for(int i = digits.length-1;i>=0;i--) {
            digits[i]+=temp;
            if(digits[i]>=10) {
                temp=digits[i]/10;
                digits[i]-=10*temp;
            } else{
                temp = 0;
            }
        }
        if(digits[0]==0&&temp>=1) {
            int[] res  = new int[digits.length+1];
            res[0]=1;
           return res;
            
        }
        return digits;
    }
}
```

找最长后缀9，第一个不为9的数+1，将末尾9置零：

```java
class Solution {
    public int[] plusOne(int[] digits) {
        for(int i = digits.length-1;i>=0;i--) {
            if(digits[i]!=9) {
                ++digits[i];
                for(int j=i+1;j<digits.length;j++) {
                    digits[j]=0;
                }
                return digits;
            } 
        }
        int[] res = new int [digits.length+1];
        res[0]=1;
        return res;        
    }
}
```



## [Medium] 380. Insert Delete GetRandom O(1)

Implement the `RandomizedSet` class:

- `RandomizedSet()` Initializes the `RandomizedSet` object.
- `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present, `false` otherwise.
- `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present, `false` otherwise.
- `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.

You must implement the functions of the class such that each function works in **average** `O(1)` time complexity.

 

**Example 1:**

```
Input
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
```

 

**Constraints:**

- `-2^31 <= val <= 2^31 - 1`
- At most `2 * 10^5` calls will be made to `insert`, `remove`, and `getRandom`.
- There will be **at least one** element in the data structure when `getRandom` is called.



### Solution

重点:  插入时记录每个元素的位置，remove时用最后的element去替换要删除的元素，删除dict中的键值对，删除list的最后一个元素。

```java
class RandomizedSet {
    
    Map<Integer, Integer> dict= new HashMap();
    List<Integer> list = new ArrayList();
    Random rand = new Random();

    public RandomizedSet() {
    }
    
    public boolean insert(int val) {
        if(dict.containsKey(val)){
            return false;
        }
        dict.put(val,list.size());
        list.add(list.size(),val);
        return true;
    }
    
    public boolean remove(int val) {
        if(!dict.containsKey(val)){
            return false;
        }
        int lastElement = list.get(list.size()-1);
        int id = dict.get(val);
        list.set(id,lastElement);
        dict.put(lastElement,id);
        list.remove(list.size()-1);
        dict.remove(val);
        return true;
    }
    
    public int getRandom() {
        return list.get(rand.nextInt(list.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```



## [Medium] 229. Majority Element II

Given an integer array of size `n`, find all elements that appear more than `⌊ n/3 ⌋` times.

 

**Example 1:**

```
Input: nums = [3,2,3]
Output: [3]
```

**Example 2:**

```
Input: nums = [1]
Output: [1]
```

**Example 3:**

```
Input: nums = [1,2]
Output: [1,2]
```

 

**Constraints:**

- `1 <= nums.length <= 5 * 104`
- `-109 <= nums[i] <= 109`

 

**Follow up:** Could you solve the problem in linear time and in `O(1)` space?



### Solution

 Boyer-Moore Voting Algorithm

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> ans;
        int vote1=0,vote2=0,element1=0,element2=0;
        for(int num:nums) {
            if(vote1>0&&num==element1){
                vote1++;
            } else if(vote2>0&&num==element2) {
                vote2++;
            } else if(vote1==0){
                vote1++;
                element1 = num;
            } else if (vote2==0) {
                vote2++;
                element2 = num;
            } else {
                vote2--;
                vote1--;
            }
        }

        int count1 = 0, count2 = 0;
        for(int num:nums) {
            if(vote1>0&&num==element1) {
                count1++;
            }
            if(vote2>0&&num==element2) {
                count2++;
            }
        }

        ans = new ArrayList<>();
        if(vote1>0&&count1>nums.length/3){
            ans.add(element1);
        }
        if(vote2>0&&count2>nums.length/3){
            ans.add(element2);
        }
        
        return ans;
    }
}
```



## [Medium] 451. Sort Characters By Frequency

Given a string `s`, sort it in **decreasing order** based on the **frequency** of the characters. The **frequency** of a character is the number of times it appears in the string.

Return *the sorted string*. If there are multiple answers, return *any of them*.

 

**Example 1:**

```
Input: s = "tree"
Output: "eert"
Explanation: 'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
```

**Example 2:**

```
Input: s = "cccaaa"
Output: "aaaccc"
Explanation: Both 'c' and 'a' appear three times, so both "cccaaa" and "aaaccc" are valid answers.
Note that "cacaca" is incorrect, as the same characters must be together.
```

**Example 3:**

```
Input: s = "Aabb"
Output: "bbAa"
Explanation: "bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
```

 

**Constraints:**

- `1 <= s.length <= 5 * 105`
- `s` consists of uppercase and lowercase English letters and digits.



### Solution

```java
class Solution {
public:
    static bool cmp(pair<char, int> p1, pair<char, int> p2){
	    return p1.second > p2.second;
    }
    string frequencySort(string s) {
        map<char,int> m;
        string res;
        for(int i = 0;i < s.size();i++){
            m[s[i]]++;
        }
        vector<pair<char,int>> v;
        for(auto x: m)
        {
            v.push_back({x.first,x.second});
        }
        sort(v.begin(), v.end(), cmp);
        for(auto itr = v.begin(); itr != v.end(); ++itr) {
            for(int k=0;k<itr->second;k++) {
                res+=(itr->first);
            }            
	    }
        return res;
    }

};
```



## [Easy] 492. Construct the Rectangle

A web developer needs to know how to design a web page's size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:

1. The area of the rectangular web page you designed must equal to the given target area.
2. The width `W` should not be larger than the length `L`, which means `L >= W`.
3. The difference between length `L` and width `W` should be as small as possible.

Return *an array `[L, W]` where `L` and `W` are the length and width of the web page you designed in sequence.*

 

**Example 1:**

```
Input: area = 4
Output: [2,2]
Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
```

**Example 2:**

```
Input: area = 37
Output: [37,1]
```

**Example 3:**

```
Input: area = 122122
Output: [427,286]
```

 

**Constraints:**

- `1 <= area <= 107`

### Solution

area除以它一个数，直到能整除，输出商和这个数；这数从area的平方根开始递减，最坏情况降到1；

```java
class Solution {
    public int[] constructRectangle(int area) {
        for(int i = (int)(Math.sqrt(area)); ;i--) {
            if(area%i==0) return new int[]{area/i,i};
        }
    }
}
```



## [Hard] 154. Find Minimum in Rotated Sorted Array II

Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:

- `[4,5,6,7,0,1,4]` if it was rotated `4` times.
- `[0,1,4,4,5,6,7]` if it was rotated `7` times.

Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` that may contain **duplicates**, return *the minimum element of this array*.

You must decrease the overall operation steps as much as possible.

 

**Example 1:**

```
Input: nums = [1,3,5]
Output: 1
```

**Example 2:**

```
Input: nums = [2,2,2,0,1]
Output: 0
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` is sorted and rotated between `1` and `n` times.

 

**Follow up:** This problem is similar to [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/), but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?



### Solution

Bin Search

```java
class Solution {
    public int findMin(int[] nums) {
        int lo = 0,hi=nums.length-1;
        if (nums[lo] < nums[hi]) return nums[lo];
        while(lo<hi) {
            int mid = lo + (hi - lo) / 2;
            if(nums[mid]<nums[hi]){
                hi = mid;
            }else if(nums[mid]>nums[hi]){
                lo = mid+1;
            } else{
                 hi--;
            }
        } 
        return nums[hi];
    }

}
```





## [Easy]496. Next Greater Element I

The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.

You are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.

For each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.

Return *an array* `ans` *of length* `nums1.length` *such that* `ans[i]` *is the **next greater element** as described above.*

 

**Example 1:**

```
Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
```

**Example 2:**

```
Input: nums1 = [2,4], nums2 = [1,2,3,4]
Output: [3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.
```

 

**Constraints:**

- `1 <= nums1.length <= nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 104`
- All integers in `nums1` and `nums2` are **unique**.
- All the integers of `nums1` also appear in `nums2`.

### Solution

单调栈经典例题

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer,Integer> res = nextGreater(nums2);
        int[] resores = new int[nums1.length];
        for(int i =0;i<nums1.length;i++){
            resores[i] = res.getOrDefault(nums1[i], -1);;
        }
        return resores;
    }

    private Map<Integer,Integer> nextGreater(int[] arr){
        Stack<Integer> stack = new Stack<>();
        Map<Integer, Integer> map = new HashMap<>();
        for(int i = 0;i<arr.length;i++){
            while(!stack.isEmpty() &&stack.peek() <arr[i]){
                 map.put(stack.pop(), arr[i]);
            }
            stack.push(arr[i]);
        }
        return map;
    }
}
```



## [Easy] 226. Invert Binary Tree

Given the `root` of a binary tree, invert the tree, and return *its root*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/invert1-tree.jpg)

```
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
Input: root = [2,1,3]
Output: [2,3,1]
```

**Example 3:**

```
Input: root = []
Output: []
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[0, 100]`.
- `-100 <= Node.val <= 100`



### Solution

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode  new_root = root;
        if(root.left!=null||root.right!=null) {
            TreeNode  temp = root.left;
            root.left = root.right;
            root.right = temp;
            root.left = invertTree(root.left);
            root.right = invertTree(root.right);
        }
        return new_root;
    }
}
```



## [Medium] 75. Sort Colors

Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

 

**Example 1:**

```
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

**Example 2:**

```
Input: nums = [2,0,1]
Output: [0,1,2]
```

**Example 3:**

```
Input: nums = [0]
Output: [0]
```

**Example 4:**

```
Input: nums = [1]
Output: [1]
```

 

**Constraints:**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` is `0`, `1`, or `2`.



### Solution

用的快排，时间$O(nlogn)$, 空间$O(logn)$

```java
class Solution {
    public void sortColors(int[] nums) {
        quickSort(nums,0,nums.length-1);
    }
    private int[] quickSort(int[] num,int left, int right){
        if(left<right){
            int partitionIndex = partition(num,left,right);
            quickSort(num,left,partitionIndex-1);
            quickSort(num,partitionIndex+1,right);
        }
        return num;
    }
    private int partition(int arr[],int left ,int right) {
        int j = left+1;
        for(int k = j;k<=right;k++){
            if(arr[k]<arr[left]){
                swap(arr,k,j);
                j++;
            }
        }
        swap(arr,left,j-1);
        return j-1;
    }
    private int[] swap(int[] arr,int left,int right){
        if(left!=right){
            arr[left] = arr[left]^arr[right];
            arr[right] = arr[left]^arr[right];
            arr[left] = arr[left]^arr[right];
        }
        return arr;
    }
}
```

**Follow up:** Could you come up with a one-pass algorithm using only constant extra space?

我的快排空间复杂度不满足QAQ，针对这道题改一下：

```java
class Solution {
    public void sortColors(int[] nums) {
        if(nums.length<2) return;
        int zero = 0;
        int two = nums.length;
        int i = 0;
        while(i<two){
            if(nums[i]==0){
                swap(nums,zero,i);
                zero++;
                i++;
            } else if(nums[i]==1){
                i++;
            } else{
                two--;
                swap(nums,two,i);
            }
        }
        
        
    }
    private int[] swap(int[] arr,int left,int right){
        if(left!=right){
            arr[left] = arr[left]^arr[right];
            arr[right] = arr[left]^arr[right];
            arr[left] = arr[left]^arr[right];
        }
        return arr;
    }
}
```



## [Hard] 301. Remove Invalid Parentheses

Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.

Return *all the possible results*. You may return the answer in **any order**.

 

**Example 1:**

```
Input: s = "()())()"
Output: ["(())()","()()()"]
```

**Example 2:**

```
Input: s = "(a)())()"
Output: ["(a())()","(a)()()"]
```

**Example 3:**

```
Input: s = ")("
Output: [""]
```

 

**Constraints:**

- `1 <= s.length <= 25`
- `s` consists of lowercase English letters and parentheses `'('` and `')'`.
- There will be at most `20` parentheses in `s`.



### Solution

广度优先搜索

注意到题目中要求最少删除，这样的描述正是广度优先搜索算法应用的场景，并且题目也要求我们输出所有的结果。我们在进行广度优先搜索时每一轮删除字符串中的 11 个括号，直到出现合法匹配的字符串为止，此时进行轮转的次数即为最少需要删除括号的个数。

我们进行广度优先搜索时，每次保存上一轮搜索的结果，然后对上一轮已经保存的结果中的每一个字符串尝试所有可能的删除一个括号的方法，然后将保存的结果进行下一轮搜索。在保存结果时，我们可以利用哈希表对上一轮生成的结果去重，从而提高效率。`

```java
class Solution {
    public List<String> removeInvalidParentheses(String s) {
        List<String> ans = new ArrayList<String>();
        Set<String> currentSet =  new HashSet<String>();
        currentSet.add(s);
        while(true){
            for(String str:currentSet) {
                if(isVaild(str)){
                    ans.add(str);
                }
            }
            if(ans.size()>0){
                return ans;
            }
            Set<String> nextSet =  new HashSet<String>();
            for(String str:currentSet){
                for(int i=0;i<str.length();i++){
                    if(i>0&&str.charAt(i)==str.charAt(i-1)){
                        continue;
                    }
                    if(str.charAt(i)=='('||str.charAt(i)==')') {
                        nextSet.add(str.substring(0,i)+str.substring(i+1));
                    }
                }
            }
            currentSet = nextSet;
        }
    }

    private boolean isVaild(String str ){
        char[] ss = str.toCharArray();
        int count = 0;
        for(char s:ss){
            if(s=='('){
                count++;
            } else if(s==')'){
                count--;
                if(count<0){
                    return false;
                }
            }
        }
        return count == 0;
    }
}
```

**复杂度分析**

- 时间复杂度：$O(n \times 2^n)$，其中 $n$ 为字符串的长度。考虑到一个字符串最多可能有 $2^n$ 个子序列，因此时间复杂度为 $O(n \times 2^n)$。
- 空间复杂度：$O(n \times C_n^\frac{n}{2})$，其中 $n$为字符串的长度。我们在进行第 $i$ 轮迭代时，会从原始字符串中删除 $i$个括号，因此第 $i$轮迭代产生的字符串最多有 $C_n^i $个，当$ i = \frac{n}{2}$时组合数最大，此时迭代生成的字符串个数最多，因此空间复杂度为$ O(n \times C_n^\frac{n}{2})$。

## [Medium] 15. 3Sum

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

 

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Example 2:**

```
Input: nums = []
Output: []
```

**Example 3:**

```
Input: nums = [0]
Output: []
```

 

**Constraints:**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`



### Solution

排序后固定一个指针移动两个指针，找到和为0的加到List里面

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int i = 0;i<nums.length-2;i++){//i<j<k故i最大也小于length-2
            if(nums[i]>0) break;//因为已排好序，若i对应元素已经大于零了，就没必要继续匹配了
            if(i>0&&nums[i]==nums[i-1]) continue;
            int j=i+1,k=nums.length-1;//j从i的后面开始移动，k从末尾往前移动
            while(j<k){
                int sum = nums[i]+nums[j]+nums[k];
                if(sum<0){
                    while(j<k&&nums[j]==nums[++j]);//若相同继续移动
                } else if (sum>0){
                    while(j<k&&nums[k]==nums[--k]);//k从后往前移
                } else{
                    res.add(new ArrayList(Arrays.asList(nums[i],nums[j],nums[k])));
                    while(j<k&&nums[j]==nums[++j]);//j继续后移
                    while(j<k&&nums[k]==nums[--k]);//k继续前移
                }
            }
        }
        return res;
    }
}
```



## [Medium] 869. Reordered Power of 2

You are given an integer `n`. We reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return `true` *if and only if we can do this so that the resulting number is a power of two*.

 

**Example 1:**

```
Input: n = 1
Output: true
```

**Example 2:**

```
Input: n = 10
Output: false
```

**Example 3:**

```
Input: n = 16
Output: true
```

**Example 4:**

```
Input: n = 24
Output: false
```

**Example 5:**

```
Input: n = 46
Output: true
```

 

**Constraints:**

- `1 <= n <= 109`



### Solution

打表＋词频统计

由于$ 2^{29} < 10^9 < 2^{30}$，因此在$ [1,10^9]$范围内有 $2^0,2^1,\cdots,2^{29}$ 一共$30$ 个$ 2$ 的幂。对这 $30$个数的每个数，我们可以预处理其十进制表示的字符数组中从 $\texttt{0} $到$ \texttt{9}$ 每个字符的出现次数，记在一个长度为$10$ 的数组中，并用一哈希表记录这些数组。对于数字 $n$，我们同样统计其十进制表示的字符数组中从$ \texttt{0}$ 到 $\texttt{9}$每个字符的出现次数，然后去哈希表中查找，若存在则说明 $n$ 可以通过重排得到$ 2 $的幂，否则不能。

```java
class Solution {
    Set<String> set = new HashSet<>();
    public boolean reorderedPowerOf2(int n) {
        init();
        return set.contains(countDigits(n));
    }
    private void init() {
        for(int i = 1;i <= 1e9;i<<=1) {
            set.add(countDigits(i));
        }
    }
    private String countDigits(int n) {
        char[] cnt = new char[10];
        while(n > 0) {
            ++cnt[n % 10];
            n /= 10;
        }
        return new String(cnt);
    }
}
```



## [Hard] 335. Self Crossing

You are given an array of integers `distance`.

You start at point `(0,0)` on an **X-Y** plane and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.

Return `true` if your path crosses itself, and `false` if it does not.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg)

```
Input: distance = [2,1,1,2]
Output: true
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/14/selfcross2-plane.jpg)

```
Input: distance = [1,2,3,4]
Output: false
```

**Example 3:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/selfcross3-plane.jpg)

```
Input: distance = [1,1,1,1]
Output: true
```

 

**Constraints:**

- `1 <= distance.length <= 105`
- `1 <= distance[i] <= 105`



### Solution

没考虑到外卷转内卷的情况，没做出来QAQ

题解：

```java
class Solution {
    public boolean isSelfCrossing(int[] distance) {
        int n=distance.length;
        if(n<4) return false;
        int i = 2;

        //外卷
        while(i<n&&distance[i]>distance[i-2]) i++;

        //如果直接干完了，说明不相交
        if(i==n) return false;

        //外卷转内卷，i-1的长度减i-3的长度
        if(distance[i]>=distance[i-2]-(i<4 ? 0:distance[i-4])){
            distance[i-1] -= i<3 ? 0:distance[i-3];
        }
        //一直内卷
        for(++i;i<n&&distance[i]<distance[i-2];i++);

        //如果i能走完说明不相交，否则相交
        return i!=n;
    }
}
```



## [Medium] 260. Single Number III

Given an integer array `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in **any order**.

You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.

 

**Example 1:**

```
Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
```

**Example 2:**

```
Input: nums = [-1,0]
Output: [-1,0]
```

**Example 3:**

```
Input: nums = [0,1]
Output: [1,0]
```

 

**Constraints:**

- `2 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- Each integer in `nums` will appear twice, only two integers will appear once.



### Solution

利用异或性质

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        /*if(nums.length==2){
            return nums;
        }*/
        int temp=0;
        for(int n:nums){
            temp^=n;
        }
        int temp2=(~temp+1)&temp;//得到最右边的1
        int temp3=temp;
        for(int n:nums){
            if((n&temp2)>0){//那一位是1的
                temp3^=n;
            }
        }
        return new int[]{temp3,temp3^temp};
    }
}
```



## [Easy] 500. Keyboard Row

Given an array of strings `words`, return *the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below*.

In the **American keyboard**:

- the first row consists of the characters `"qwertyuiop"`,
- the second row consists of the characters `"asdfghjkl"`, and
- the third row consists of the characters `"zxcvbnm"`.

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/keyboard.png)

 

**Example 1:**

```
Input: words = ["Hello","Alaska","Dad","Peace"]
Output: ["Alaska","Dad"]
```

**Example 2:**

```
Input: words = ["omk"]
Output: []
```

**Example 3:**

```
Input: words = ["adsdf","sfd"]
Output: ["adsdf","sfd"]
```

### Solution

```java
class Solution {
    static String[] ss = new String[]{"qwertyuiop","asdfghjkl","zxcvbnm"};
    static int[] hash = new int[26];
    static{
        for(int i=0;i<ss.length;i++){
            for(char c:ss[i].toCharArray()){
                hash[c-'a']=i;
            }
        }
    }
    public String[] findWords(String[] words) {
        List<String> list = new ArrayList<String>();
        for(String word : words){
            int idx = hash[Character.toLowerCase(word.charAt(0))-'a'];
            boolean isVaild = true;
            for(int i=1;i<word.length();i++){
                if(hash[Character.toLowerCase(word.charAt(i))-'a']!=idx){
                    isVaild=false;
                    break;
                }
            }
            if(isVaild){
                list.add(word);
            }
        }
        String[] ans = new String[list.size()];
        for(int i=0;i<list.size();i++){
            ans[i]=list.get(i);
        }
        return ans;
    }
}
```



## [Easy] 575. Distribute Candies

Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.

The doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.

Given the integer array `candyType` of length `n`, return *the **maximum** number of different types of candies she can eat if she only eats* `n / 2` *of them*.

 

**Example 1:**

```
Input: candyType = [1,1,2,2,3,3]
Output: 3
Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.
```

**Example 2:**

```
Input: candyType = [1,1,2,3]
Output: 2
Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.
```

**Example 3:**

```
Input: candyType = [6,6,6,6]
Output: 1
Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.
```

 

**Constraints:**

- `n == candyType.length`
- `2 <= n <= 104`
- `n` is even.
- `-105 <= candyType[i] <= 105`

### Solution

Sort

```java
class Solution {
    public int distributeCandies(int[] candyType) {
        Arrays.sort(candyType);
        int count = 1;
        for(int i=1;i<candyType.length;i++){
            if(candyType[i]>candyType[i-1]){
                count++;
            }
        }
        return Math.min(count,candyType.length/2);
    }
}
```



HashSet

```java
class Solution {
    public int distributeCandies(int[] candyType) {
        Set<Integer> m = new HashSet<>();
        for(int type:candyType){
            m.add(type);
        }
        return(Math.min(m.size(),candyType.length/2));
    }
}
```



## [Medium] 130. Surrounded Regions

Given an `m x n` matrix `board` containing `'X'` and `'O'`, *capture all regions that are 4-directionally surrounded by* `'X'`.

A region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded region.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

```
Input: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
Output: [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
Explanation: Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
```

**Example 2:**

```
Input: board = [["X"]]
Output: [["X"]]
```

 

**Constraints:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 200`
- `board[i][j]` is `'X'` or `'O'`.

### Solution

dfs ! 从边界调DFS，被遍历到的结点为不被X包围的区域内的，未被遍历到的应是被X阻隔导致DFS无法遍历到的，按题意将其置X

```java
class Solution {
    public void solve(char[][] board) {
        if(board.length==1||board.length==0){
            return;
        }
        
        for(int i=0;i<board.length;i++){
            dfs(board,i,0);
            dfs(board,i,board[0].length-1);
        }
        for(int j=1;j<board[0].length-1;j++){
            dfs(board,0,j);
            dfs(board,board.length-1,j);
        }
        
        for(int i=0;i<board.length;i++){
            for(int j=0;j<board[0].length;j++){
                if(board[i][j]=='F'){
                    board[i][j]='O';
                }else if(board[i][j]=='O'){
                    board[i][j]='X';
                }
            }
        }
    }
    private void dfs(char[][] board,int x,int y){
        if(x>=board.length||x<0||y<0||y>=board[0].length||board[x][y]=='F'||board[x][y]=='X')return;
        board[x][y] = 'F';
        dfs(board,x+1,y);
        dfs(board,x-1,y);
        dfs(board,x,y+1);
        dfs(board,x,y-1);
        return;
    }
}
```



## [Easy] 237. Delete Node in a Linked List

Write a function to **delete a node** in a singly-linked list. You will **not** be given access to the `head` of the list, instead you will be given access to **the node to be deleted** directly.

It is **guaranteed** that the node to be deleted is **not a tail node** in the list.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/01/node1.jpg)

```
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/09/01/node2.jpg)

```
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
```

**Example 3:**

```
Input: head = [1,2,3,4], node = 3
Output: [1,2,4]
```

**Example 4:**

```
Input: head = [0,1], node = 0
Output: [1]
```

**Example 5:**

```
Input: head = [-3,5,-99], node = -3
Output: [5,-99]
```

 

**Constraints:**

- The number of the nodes in the given list is in the range `[2, 1000]`.
- `-1000 <= Node.val <= 1000`
- The value of each node in the list is **unique**.
- The `node` to be deleted is **in the list** and is **not a tail** node



### Solution

因为此结点一定不是尾结点，所以可以复制它的下一结点，逻辑删除它的下一结点。

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val=node.next.val;
        node.next=node.next.next;
    }
}
```



## [Hard] 980. Unique Paths III

You are given an `m x n` integer array `grid` where `grid[i][j]` could be:

- `1` representing the starting square. There is exactly one starting square.
- `2` representing the ending square. There is exactly one ending square.
- `0` representing empty squares we can walk over.
- `-1` representing obstacles that we cannot walk over.

Return *the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/lc-unique1.jpg)

```
Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
Output: 2
Explanation: We have the following two paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```

**Example 2:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/lc-unique2.jpg)

```
Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
Output: 4
Explanation: We have the following four paths: 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2021/08/02/lc-unique3-.jpg)

```
Input: grid = [[0,1],[2,0]]
Output: 0
Explanation: There is no path that walks over every empty square exactly once.
Note that the starting and ending square can be anywhere in the grid.
```

 

**Constraints:**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 20`
- `1 <= m * n <= 20`
- `-1 <= grid[i][j] <= 2`
- There is exactly one starting cell and one ending cell.

### Solution

回溯，递归第一层往4个方向dfs，这4个方向可能的路径和即为解。需要在算出当前层可能解之后将矩阵复原，以供上一层的另外的方向搜索；遇到grid\[x\]\[y\]==-1或者越界直接失败，返回0；遇到2判断zero是否都被遍历完了，若是则找到一条路径，返回1，若否，查找失败，返回0；

```java
class Solution {
    public int uniquePathsIII(int[][] grid) {
        int zero=0,x=0,y=0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j<grid[0].length; j++){
                if(grid[i][j]==0){
                    zero++;
                } else if(grid[i][j]==1){
                    x=i;
                    y=j;
                }
            }
        }
        return dfs(grid, x, y, zero);
    }
    private int dfs(int[][] grid , int x, int y, int zero){
        if(x>=grid.length||y>=grid[0].length||x<0||y<0||grid[x][y]==-1){
            return 0;
        }
        if(grid[x][y]==2){
            return (zero==-1)?1:0;
        }
        grid[x][y]=-1;
        zero--;
        int res = dfs(grid,x+1,y,zero)
                + dfs(grid,x,y+1,zero)
                + dfs(grid,x-1,y,zero)
                + dfs(grid,x,y-1,zero);
        grid[x][y]=0;
        zero++;
        return res;
    }
}
```

## [Easy] 129. Sum Root to Leaf Numbers

You are given the `root` of a binary tree containing digits from `0` to `9` only.

Each root-to-leaf path in the tree represents a number.

- For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.

Return *the total sum of all root-to-leaf numbers*. Test cases are generated so that the answer will fit in a **32-bit** integer.

A **leaf** node is a node with no children.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/num1tree.jpg)

```
Input: root = [1,2,3]
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)

```
Input: root = [4,9,0,5,1]
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 1000]`.
- `0 <= Node.val <= 9`
- The depth of the tree will not exceed `10`.

### Solution

DFS again!

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumNumbers(TreeNode root) {
        return dfs(root,0);
    }
    private int dfs(TreeNode root,int sum){
        if(root==null) return 0;
        sum=sum*10+root.val;
        if(root.left==null&&root.right==null){
            return sum;
        }
        return dfs(root.left,sum)+dfs(root.right,sum);
    }
}
```

## [Easy] 404. Sum of Left Leaves

Given the `root` of a binary tree, return the sum of all left leaves.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/leftsum-tree.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: 24
Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
```

**Example 2:**

```
Input: root = [1]
Output: 0
```

 

**Constraints:**

- The number of nodes in the tree is in the range `[1, 1000]`.
- `-1000 <= Node.val <= 1000`

### Solution

连着几天`DFS`了......今天这个还比较绕。需要算所有左叶子节点的值的和。考虑一个`dfs`函数，首先递归出口是结点为null返回0。结点存在且它是左叶子（标记为true并且左右子结点不存在），令它的值加上左边`dfs`(因为只有向左递归调用才有可能找到左叶子，所以令flag=true)和右边`dfs`得到的值为此函数的返回值。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        return dfs(root,false);
    }
    private int dfs(TreeNode root,boolean flag){
        if(root==null) return 0;
        return (flag&&root.left==null&&root.right==null)?root.val:0+dfs(root.left,true)+dfs(root.right,false);
    }
}
```

## [Easy] 367. Valid Perfect Square

Given a **positive** integer *num*, write a function which returns True if *num* is a perfect square else False.

**Follow up:** **Do not** use any built-in library function such as `sqrt`.

 

**Example 1:**

```
Input: num = 16
Output: true
```

**Example 2:**

```
Input: num = 14
Output: false
```

 

**Constraints:**

- `1 <= num <= 2^31 - 1`

### Solution

基于二分查找做

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        long l=0,r=num;
        while(l<r){
           long mid = (l+r+1)>>1;
           if(mid*mid<=num) l=mid;
           else r=mid-1; 
        }
        return r*r==num;
    }
}
```

## [Easy] 441. Arranging Coins

You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `ith` row has exactly `i` coins. The last row of the staircase **may be** incomplete.

Given the integer `n`, return *the number of **complete rows** of the staircase you will build*.

 

**Example 1:**

![img](https://gitee.com/niimi_sora/pic-upload/raw/master/pics/arrangecoins1-grid.jpg)

```
Input: n = 5
Output: 2
Explanation: Because the 3rd row is incomplete, we return 2.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg)

```
Input: n = 8
Output: 3
Explanation: Because the 4th row is incomplete, we return 3.
```

 

**Constraints:**

- `1 <= n <= 231 - 1`

### Solution

暴力

```java
class Solution {
    public int arrangeCoins(int n) {
        int i=1;
        while(n>0){
            i++;
            n=n-i;
        }
        return i-1;
    }
}
```

数学归纳

```java
class Solution {
    public int arrangeCoins(int n) {
        return (int) (Math.sqrt(2 * (long) n + 0.25) - 0.5);
    }
}
```













# tricks

## 多数问题：摩尔投票法

 Boyer-Moore Voting Algorithm, 又称为多数投票法，摩尔投票法的一大应用就是**求众数**。

  摩尔投票法基于这样一个事实，**当一个数的重复次数超过数组长度的一半，每次将两个不相同的数删除，最终剩下的就是要找的数。**

摩尔投票法分为两个阶段：**抵消阶段和计数阶段**。

  **抵消阶段**：两个不同投票进行对坑，并且同时抵消掉各一张票，如果两个投票相同，则累加可抵消的次数；

  **计数阶段**：在抵消阶段最后得到的抵消计数只要不为 0，那这个候选人是有可能超过一半的票数的，为了验证，则需要遍历一次，统计票数，才可确定。

==算法步骤==：

1. `count = 0；` ` num = nums[0];` 表示从此时开始计算投票。

2. 遍历数组，如果接下来出现的数字与`num`相同，`count`加1。如果不同，`count`减1。

3. 如果`count == 0`，表示之前出现的所有数字中`num`都是可以凑成不同的数对，一起抵消。大于`1/2 n`的数还会在后面出现。

4. 如果`count < 0`，表示之前`num`中的数字没有到一半，所以此时完全不用考虑前面存储的元素，“删除”他们。直接从现在的新的元素开始计数，并令`count = 0`。

对于出现超过`n/2`次数的元素：

```java
class Solution {
    public int majorityElement(int[] nums) {
        int vote = 0, element = 0;
        for(int num : nums) {
            if(vote > 0 && num == element) {
                vote++;
            } else if(vote==0) {
                vote++;
                element = num;
            } else {
                vote--;
            }
        }
        return element;
    }
}
```

对于出现超过`n/3`次数的元素：

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> ans;
        int vote1 = 0, vote2 = 0, element1 = 0, element2 = 0;
        for(int num : nums) {
            if(vote1 > 0 && num == element1){
                vote1++;
            } else if(vote2 > 0 && num == element2) {
                vote2++;
            } else if(vote1 == 0) {
                vote1++;
                element1 = num;
            } else if (vote2==0) {
                vote2++;
                element2 = num;
            } else {
                vote2--;
                vote1--;
            }
        }

        int count1 = 0, count2 = 0;
        for(int num : nums) {
            if(vote1 > 0 && num == element1) {
                count1++;
            }
            if(vote2 > 0 && num == element2) {
                count2++;
            }
        }

        ans = new ArrayList<>();
        if(vote1 > 0 && count1 > nums.length / 3){
            ans.add(element1);
        }
        if(vote2 > 0 && count2 > nums.length / 3){
            ans.add(element2);
        }
        
        return ans;
    }
}
```

可以扩展至找出出现次数超过`1/k`次的元素的问题：

**至多选出m个代表，每个选票数大于n / (m + 1)**





## 折半查找/二分搜索

对于有序的数组，优先考虑这个

## 单调栈



## DFS

